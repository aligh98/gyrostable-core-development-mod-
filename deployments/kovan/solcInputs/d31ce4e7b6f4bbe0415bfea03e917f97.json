{
  "language": "Solidity",
  "sources": {
    "contracts/abdk/ABDKMath64x64.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.7.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n    /*\n     * Minimum value signed 64.64-bit fixed point number may have.\n     */\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n    /*\n     * Maximum value signed 64.64-bit fixed point number may have.\n     */\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    /**\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x signed 256-bit integer number\n     * @return signed 64.64-bit fixed point number\n     */\n    function fromInt(int256 x) internal pure returns (int128) {\n        require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n        return int128(x << 64);\n    }\n\n    /**\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\n     * rounding down.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64-bit integer number\n     */\n    function toInt(int128 x) internal pure returns (int64) {\n        return int64(x >> 64);\n    }\n\n    /**\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x unsigned 256-bit integer number\n     * @return signed 64.64-bit fixed point number\n     */\n    function fromUInt(uint256 x) internal pure returns (int128) {\n        require(\n            x <= 0x7FFFFFFFFFFFFFFF,\n            \"value is too high to be transformed in a 64.64-bit number\"\n        );\n        return int128(x << 64);\n    }\n\n    /**\n     * Convert unsigned 256-bit integer number scaled with 10^decimals into signed 64.64-bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x unsigned 256-bit integer number\n     * @param decimal scale of the number\n     * @return signed 64.64-bit fixed point number\n     */\n    function fromScaled(uint256 x, uint256 decimal) internal pure returns (int128) {\n        uint256 scale = 10**decimal;\n        int128 wholeNumber = fromUInt(x / scale);\n        int128 decimalNumber = div(fromUInt(x % scale), fromUInt(scale));\n        return add(wholeNumber, decimalNumber);\n    }\n\n    /**\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n     * number rounding down.  Revert on underflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return unsigned 64-bit integer number\n     */\n    function toUInt(int128 x) internal pure returns (uint64) {\n        require(x >= 0);\n        return uint64(x >> 64);\n    }\n\n    /**\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n     * number rounding down.  Revert on overflow.\n     *\n     * @param x signed 128.128-bin fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function from128x128(int256 x) internal pure returns (int128) {\n        int256 result = x >> 64;\n        require(result >= MIN_64x64 && result <= MAX_64x64);\n        return int128(result);\n    }\n\n    /**\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n     * number.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 128.128 fixed point number\n     */\n    function to128x128(int128 x) internal pure returns (int256) {\n        return int256(x) << 64;\n    }\n\n    /**\n     * Calculate x + y.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @param y signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function add(int128 x, int128 y) internal pure returns (int128) {\n        int256 result = int256(x) + y;\n        require(result >= MIN_64x64 && result <= MAX_64x64);\n        return int128(result);\n    }\n\n    /**\n     * Calculate x - y.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @param y signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function sub(int128 x, int128 y) internal pure returns (int128) {\n        int256 result = int256(x) - y;\n        require(result >= MIN_64x64 && result <= MAX_64x64);\n        return int128(result);\n    }\n\n    /**\n     * Calculate x * y rounding down.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @param y signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function mul(int128 x, int128 y) internal pure returns (int128) {\n        int256 result = (int256(x) * y) >> 64;\n        require(result >= MIN_64x64 && result <= MAX_64x64);\n        return int128(result);\n    }\n\n    /**\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n     * number and y is signed 256-bit integer number.  Revert on overflow.\n     *\n     * @param x signed 64.64 fixed point number\n     * @param y signed 256-bit integer number\n     * @return signed 256-bit integer number\n     */\n    function muli(int128 x, int256 y) internal pure returns (int256) {\n        if (x == MIN_64x64) {\n            require(\n                y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n                    y <= 0x1000000000000000000000000000000000000000000000000\n            );\n            return -y << 63;\n        } else {\n            bool negativeResult = false;\n            if (x < 0) {\n                x = -x;\n                negativeResult = true;\n            }\n            if (y < 0) {\n                y = -y; // We rely on overflow behavior here\n                negativeResult = !negativeResult;\n            }\n            uint256 absoluteResult = mulu(x, uint256(y));\n            if (negativeResult) {\n                require(\n                    absoluteResult <=\n                        0x8000000000000000000000000000000000000000000000000000000000000000\n                );\n                return -int256(absoluteResult); // We rely on overflow behavior here\n            } else {\n                require(\n                    absoluteResult <=\n                        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                );\n                return int256(absoluteResult);\n            }\n        }\n    }\n\n    /**\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\n     *\n     * @param x signed 64.64 fixed point number\n     * @param y unsigned 256-bit integer number\n     * @return unsigned 256-bit integer number\n     */\n    function mulu(int128 x, uint256 y) internal pure returns (uint256) {\n        if (y == 0) return 0;\n\n        require(x >= 0);\n\n        uint256 lo = (uint256(x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n        uint256 hi = uint256(x) * (y >> 128);\n\n        require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        hi <<= 64;\n\n        require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n        return hi + lo;\n    }\n\n    /**\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n     * zero.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @param y signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function div(int128 x, int128 y) internal pure returns (int128) {\n        require(y != 0);\n        int256 result = (int256(x) << 64) / y;\n        require(result >= MIN_64x64 && result <= MAX_64x64);\n        return int128(result);\n    }\n\n    /**\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n     * integer numbers.  Revert on overflow or when y is zero.\n     *\n     * @param x signed 256-bit integer number\n     * @param y signed 256-bit integer number\n     * @return signed 64.64-bit fixed point number\n     */\n    function divi(int256 x, int256 y) internal pure returns (int128) {\n        require(y != 0);\n\n        bool negativeResult = false;\n        if (x < 0) {\n            x = -x; // We rely on overflow behavior here\n            negativeResult = true;\n        }\n        if (y < 0) {\n            y = -y; // We rely on overflow behavior here\n            negativeResult = !negativeResult;\n        }\n        uint128 absoluteResult = divuu(uint256(x), uint256(y));\n        if (negativeResult) {\n            require(absoluteResult <= 0x80000000000000000000000000000000);\n            return -int128(absoluteResult); // We rely on overflow behavior here\n        } else {\n            require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n            return int128(absoluteResult); // We rely on overflow behavior here\n        }\n    }\n\n    /**\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n     * integer numbers.  Revert on overflow or when y is zero.\n     *\n     * @param x unsigned 256-bit integer number\n     * @param y unsigned 256-bit integer number\n     * @return signed 64.64-bit fixed point number\n     */\n    function divu(uint256 x, uint256 y) internal pure returns (int128) {\n        require(y != 0);\n        uint128 result = divuu(x, y);\n        require(result <= uint128(MAX_64x64));\n        return int128(result);\n    }\n\n    /**\n     * Calculate -x.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function neg(int128 x) internal pure returns (int128) {\n        require(x != MIN_64x64);\n        return -x;\n    }\n\n    /**\n     * Calculate |x|.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function abs(int128 x) internal pure returns (int128) {\n        require(x != MIN_64x64);\n        return x < 0 ? -x : x;\n    }\n\n    /**\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n     * zero.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function inv(int128 x) internal pure returns (int128) {\n        require(x != 0);\n        int256 result = int256(0x100000000000000000000000000000000) / x;\n        require(result >= MIN_64x64 && result <= MAX_64x64);\n        return int128(result);\n    }\n\n    /**\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @param y signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function avg(int128 x, int128 y) internal pure returns (int128) {\n        return int128((int256(x) + int256(y)) >> 1);\n    }\n\n    /**\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n     * Revert on overflow or in case x * y is negative.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @param y signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function gavg(int128 x, int128 y) internal pure returns (int128) {\n        int256 m = int256(x) * int256(y);\n        require(m >= 0);\n        require(m < 0x4000000000000000000000000000000000000000000000000000000000000000);\n        return int128(sqrtu(uint256(m)));\n    }\n\n    /**\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @param y uint256 value\n     * @return signed 64.64-bit fixed point number\n     */\n    function pow(int128 x, uint256 y) internal pure returns (int128) {\n        uint256 absoluteResult;\n        bool negativeResult = false;\n        if (x >= 0) {\n            absoluteResult = powu(uint256(x) << 63, y);\n        } else {\n            // We rely on overflow behavior here\n            absoluteResult = powu(uint256(uint128(-x)) << 63, y);\n            negativeResult = y & 1 > 0;\n        }\n\n        absoluteResult >>= 63;\n\n        if (negativeResult) {\n            require(absoluteResult <= 0x80000000000000000000000000000000);\n            return -int128(absoluteResult); // We rely on overflow behavior here\n        } else {\n            require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n            return int128(absoluteResult); // We rely on overflow behavior here\n        }\n    }\n\n    /**\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function sqrt(int128 x) internal pure returns (int128) {\n        require(x >= 0);\n        return int128(sqrtu(uint256(x) << 64));\n    }\n\n    /**\n     * Calculate binary logarithm of x.  Revert if x <= 0.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function log_2(int128 x) internal pure returns (int128) {\n        require(x > 0);\n\n        int256 msb = 0;\n        int256 xc = x;\n        if (xc >= 0x10000000000000000) {\n            xc >>= 64;\n            msb += 64;\n        }\n        if (xc >= 0x100000000) {\n            xc >>= 32;\n            msb += 32;\n        }\n        if (xc >= 0x10000) {\n            xc >>= 16;\n            msb += 16;\n        }\n        if (xc >= 0x100) {\n            xc >>= 8;\n            msb += 8;\n        }\n        if (xc >= 0x10) {\n            xc >>= 4;\n            msb += 4;\n        }\n        if (xc >= 0x4) {\n            xc >>= 2;\n            msb += 2;\n        }\n        if (xc >= 0x2) msb += 1; // No need to shift xc anymore\n\n        int256 result = (msb - 64) << 64;\n        uint256 ux = uint256(x) << uint256(127 - msb);\n        for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n            ux *= ux;\n            uint256 b = ux >> 255;\n            ux >>= 127 + b;\n            result += bit * int256(b);\n        }\n\n        return int128(result);\n    }\n\n    /**\n     * Calculate natural logarithm of x.  Revert if x <= 0.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function ln(int128 x) internal pure returns (int128) {\n        require(x > 0);\n\n        return int128((uint256(log_2(x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128);\n    }\n\n    /**\n     * Calculate binary exponent of x.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function exp_2(int128 x) internal pure returns (int128) {\n        require(x < 0x400000000000000000, \"exponent too large\"); // Overflow\n\n        if (x < -0x400000000000000000) return 0; // Underflow\n\n        uint256 result = 0x80000000000000000000000000000000;\n\n        if (x & 0x8000000000000000 > 0)\n            result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\n        if (x & 0x4000000000000000 > 0)\n            result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\n        if (x & 0x2000000000000000 > 0)\n            result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\n        if (x & 0x1000000000000000 > 0)\n            result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\n        if (x & 0x800000000000000 > 0)\n            result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\n        if (x & 0x400000000000000 > 0)\n            result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\n        if (x & 0x200000000000000 > 0)\n            result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\n        if (x & 0x100000000000000 > 0)\n            result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\n        if (x & 0x80000000000000 > 0)\n            result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\n        if (x & 0x40000000000000 > 0)\n            result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\n        if (x & 0x20000000000000 > 0)\n            result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\n        if (x & 0x10000000000000 > 0)\n            result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\n        if (x & 0x8000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\n        if (x & 0x4000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\n        if (x & 0x2000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292026) >> 128;\n        if (x & 0x1000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\n        if (x & 0x800000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\n        if (x & 0x400000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\n        if (x & 0x200000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\n        if (x & 0x100000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\n        if (x & 0x80000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\n        if (x & 0x40000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\n        if (x & 0x20000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\n        if (x & 0x10000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\n        if (x & 0x8000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\n        if (x & 0x4000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\n        if (x & 0x2000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\n        if (x & 0x1000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\n        if (x & 0x800000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\n        if (x & 0x400000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\n        if (x & 0x200000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\n        if (x & 0x100000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\n        if (x & 0x80000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\n        if (x & 0x40000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\n        if (x & 0x20000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\n        if (x & 0x10000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\n        if (x & 0x8000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\n        if (x & 0x4000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\n        if (x & 0x2000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\n        if (x & 0x1000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\n        if (x & 0x800000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\n        if (x & 0x400000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;\n        if (x & 0x200000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;\n        if (x & 0x100000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;\n        if (x & 0x80000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\n        if (x & 0x40000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\n        if (x & 0x20000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;\n        if (x & 0x10000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\n        if (x & 0x8000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\n        if (x & 0x4000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;\n        if (x & 0x2000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\n        if (x & 0x1000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\n        if (x & 0x800 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\n        if (x & 0x400 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\n        if (x & 0x200 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;\n        if (x & 0x100 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\n        if (x & 0x80 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\n        if (x & 0x40 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\n        if (x & 0x20 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\n        if (x & 0x10 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\n        if (x & 0x8 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\n        if (x & 0x4 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\n        if (x & 0x2 > 0) result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;\n        if (x & 0x1 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;\n\n        result >>= uint256(63 - (x >> 64));\n        require(result <= uint256(MAX_64x64));\n\n        return int128(result);\n    }\n\n    /**\n     * Calculate natural exponent of x.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function exp(int128 x) internal pure returns (int128) {\n        require(x < 0x400000000000000000); // Overflow\n\n        if (x < -0x400000000000000000) return 0; // Underflow\n\n        return exp_2(int128((int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128));\n    }\n\n    /**\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n     * integer numbers.  Revert on overflow or when y is zero.\n     *\n     * @param x unsigned 256-bit integer number\n     * @param y unsigned 256-bit integer number\n     * @return unsigned 64.64-bit fixed point number\n     */\n    function divuu(uint256 x, uint256 y) private pure returns (uint128) {\n        require(y != 0);\n\n        uint256 result;\n\n        if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) result = (x << 64) / y;\n        else {\n            uint256 msb = 192;\n            uint256 xc = x >> 192;\n            if (xc >= 0x100000000) {\n                xc >>= 32;\n                msb += 32;\n            }\n            if (xc >= 0x10000) {\n                xc >>= 16;\n                msb += 16;\n            }\n            if (xc >= 0x100) {\n                xc >>= 8;\n                msb += 8;\n            }\n            if (xc >= 0x10) {\n                xc >>= 4;\n                msb += 4;\n            }\n            if (xc >= 0x4) {\n                xc >>= 2;\n                msb += 2;\n            }\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\n\n            result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);\n            require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n            uint256 hi = result * (y >> 128);\n            uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n            uint256 xh = x >> 192;\n            uint256 xl = x << 64;\n\n            if (xl < lo) xh -= 1;\n            xl -= lo; // We rely on overflow behavior here\n            lo = hi << 128;\n            if (xl < lo) xh -= 1;\n            xl -= lo; // We rely on overflow behavior here\n\n            assert(xh == hi >> 128);\n\n            result += xl / y;\n        }\n\n        require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return uint128(result);\n    }\n\n    /**\n     * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\n     * number and y is unsigned 256-bit integer number.  Revert on overflow.\n     *\n     * @param x unsigned 129.127-bit fixed point number\n     * @param y uint256 value\n     * @return unsigned 129.127-bit fixed point number\n     */\n    function powu(uint256 x, uint256 y) private pure returns (uint256) {\n        if (y == 0) return 0x80000000000000000000000000000000;\n        else if (x == 0) return 0;\n        else {\n            int256 msb = 0;\n            uint256 xc = x;\n            if (xc >= 0x100000000000000000000000000000000) {\n                xc >>= 128;\n                msb += 128;\n            }\n            if (xc >= 0x10000000000000000) {\n                xc >>= 64;\n                msb += 64;\n            }\n            if (xc >= 0x100000000) {\n                xc >>= 32;\n                msb += 32;\n            }\n            if (xc >= 0x10000) {\n                xc >>= 16;\n                msb += 16;\n            }\n            if (xc >= 0x100) {\n                xc >>= 8;\n                msb += 8;\n            }\n            if (xc >= 0x10) {\n                xc >>= 4;\n                msb += 4;\n            }\n            if (xc >= 0x4) {\n                xc >>= 2;\n                msb += 2;\n            }\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\n\n            int256 xe = msb - 127;\n            if (xe > 0) x >>= uint256(xe);\n            else x <<= uint256(-xe);\n\n            uint256 result = 0x80000000000000000000000000000000;\n            int256 re = 0;\n\n            while (y > 0) {\n                if (y & 1 > 0) {\n                    result = result * x;\n                    y -= 1;\n                    re += xe;\n                    if (\n                        result >= 0x8000000000000000000000000000000000000000000000000000000000000000\n                    ) {\n                        result >>= 128;\n                        re += 1;\n                    } else result >>= 127;\n                    if (re < -127) return 0; // Underflow\n                    require(re < 128); // Overflow\n                } else {\n                    x = x * x;\n                    y >>= 1;\n                    xe <<= 1;\n                    if (x >= 0x8000000000000000000000000000000000000000000000000000000000000000) {\n                        x >>= 128;\n                        xe += 1;\n                    } else x >>= 127;\n                    if (xe < -127) return 0; // Underflow\n                    require(xe < 128); // Overflow\n                }\n            }\n\n            if (re > 0) result <<= uint256(re);\n            else if (re < 0) result >>= uint256(-re);\n\n            return result;\n        }\n    }\n\n    /**\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n     * number.\n     *\n     * @param x unsigned 256-bit integer number\n     * @return unsigned 128-bit integer number\n     */\n    function sqrtu(uint256 x) private pure returns (uint128) {\n        if (x == 0) return 0;\n        else {\n            uint256 xx = x;\n            uint256 r = 1;\n            if (xx >= 0x100000000000000000000000000000000) {\n                xx >>= 128;\n                r <<= 64;\n            }\n            if (xx >= 0x10000000000000000) {\n                xx >>= 64;\n                r <<= 32;\n            }\n            if (xx >= 0x100000000) {\n                xx >>= 32;\n                r <<= 16;\n            }\n            if (xx >= 0x10000) {\n                xx >>= 16;\n                r <<= 8;\n            }\n            if (xx >= 0x100) {\n                xx >>= 8;\n                r <<= 4;\n            }\n            if (xx >= 0x10) {\n                xx >>= 4;\n                r <<= 2;\n            }\n            if (xx >= 0x8) {\n                r <<= 1;\n            }\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1; // Seven iterations should be enough\n            uint256 r1 = x / r;\n            return uint128(r < r1 ? r : r1);\n        }\n    }\n}\n"
    },
    "contracts/MathTest.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"./abdk/ABDKMath64x64.sol\";\nimport \"./ExtendedMath.sol\";\n\ncontract MathTest {\n    using ABDKMath64x64 for uint256;\n    using ABDKMath64x64 for int128;\n    using ExtendedMath for int128;\n    using ExtendedMath for uint256;\n\n    uint256 constant expScale = 1e18;\n\n    /**\n     * @return value * (base ** exponent)\n     */\n    function mulPow(\n        uint256 value,\n        uint256 base,\n        uint256 exponent,\n        uint256 decimal\n    ) external pure returns (uint256) {\n        return value.mulPow(base, exponent, decimal);\n    }\n}\n"
    },
    "contracts/ExtendedMath.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"./abdk/ABDKMath64x64.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary ExtendedMath {\n    using ABDKMath64x64 for int128;\n    using ABDKMath64x64 for uint256;\n    using SafeMath for uint256;\n\n    uint256 constant decimals = 18;\n    uint256 constant decimalScale = 10**decimals;\n\n    function powf(int128 _x, int128 _y) internal pure returns (int128 _xExpy) {\n        // 2^(y * log2(x))\n        return _y.mul(_x.log_2()).exp_2();\n    }\n\n    /**\n     * @return value * (base ** exponent)\n     */\n    function mulPow(\n        uint256 value,\n        uint256 base,\n        uint256 exponent,\n        uint256 decimal\n    ) internal pure returns (uint256) {\n        int128 basef = base.fromScaled(decimal);\n        int128 expf = exponent.fromScaled(decimal);\n        return powf(basef, expf).mulu(value);\n    }\n\n    function scaledMul(\n        uint256 a,\n        uint256 b,\n        uint256 _decimals\n    ) internal pure returns (uint256) {\n        return a.mul(b).div(10**_decimals);\n    }\n\n    function scaledMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return scaledMul(a, b, decimals);\n    }\n\n    function scaledDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return scaledDiv(a, b, decimals);\n    }\n\n    function scaledDiv(\n        uint256 a,\n        uint256 b,\n        uint256 _decimals\n    ) internal pure returns (uint256) {\n        return a.mul(10**_decimals).div(b);\n    }\n\n    function scaledPow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        return scaledPow(base, exp, decimals);\n    }\n\n    function scaledPow(\n        uint256 base,\n        uint256 exp,\n        uint256 _decimals\n    ) internal pure returns (uint256) {\n        uint256 result = 1e18;\n        for (uint256 i = 0; i < exp; i++) {\n            result = scaledMul(result, base, _decimals);\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/Controller.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\n// import \"@nomiclabs/buidler/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./Keeper.sol\";\nimport \"./compound/CTokenInterfaces.sol\";\nimport \"./compound/ComptrollerInterface.sol\";\n\n// contract Controller is Ownable, ERC20 {}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/Keeper.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\ninterface Keeper {\n    function rebalance(\n        uint256 _minBorrowRatio,\n        uint256 _targetBorrowRatio,\n        uint256 _maxBorrowRatio,\n        uint256 _borrowRatioEpsilon,\n        uint256 _minimumDaiIncrease\n    ) external;\n}\n"
    },
    "contracts/compound/CTokenInterfaces.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\ncontract CTokenStorage {\n\n    bool internal _notEntered;\n\n\n    string public name;\n\n\n    string public symbol;\n\n\n    uint8 public decimals;\n\n\n\n    uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n\n\n    uint256 internal constant reserveFactorMaxMantissa = 1e18;\n\n    address payable public admin;\n\n\n    address payable public pendingAdmin;\n\n    ComptrollerInterface public comptroller;\n\n\n    InterestRateModel public interestRateModel;\n\n\n    uint256 internal initialExchangeRateMantissa;\n\n\n    uint256 public reserveFactorMantissa;\n\n\n    uint256 public accrualBlockNumber;\n\n\n    uint256 public borrowIndex;\n\n \n    uint256 public totalBorrows;\n\n\n    uint256 public totalReserves;\n\n\n    uint256 public totalSupply;\n\n  \n    mapping(address => uint256) internal accountTokens;\n\n \n    mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interestIndex;\n    }\n\n\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n}\n\nabstract contract CTokenInterface is CTokenStorage {\n    /**\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(\n        uint256 cashPrior,\n        uint256 interestAccumulated,\n        uint256 borrowIndex,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        address cTokenCollateral,\n        uint256 seizeTokens\n    );\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @notice Event emitted when comptroller is changed\n     */\n    event NewComptroller(\n        ComptrollerInterface oldComptroller,\n        ComptrollerInterface newComptroller\n    );\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(\n        InterestRateModel oldInterestRateModel,\n        InterestRateModel newInterestRateModel\n    );\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(\n        uint256 oldReserveFactorMantissa,\n        uint256 newReserveFactorMantissa\n    );\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(\n        address benefactor,\n        uint256 addAmount,\n        uint256 newTotalReserves\n    );\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(\n        address admin,\n        uint256 reduceAmount,\n        uint256 newTotalReserves\n    );\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /**\n     * @notice Failure event\n     */\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    /*** User Interface ***/\n\n    function transfer(address dst, uint256 amount)\n        external\n        virtual\n        returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external virtual returns (bool);\n\n    function approve(address spender, uint256 amount)\n        external\n        virtual\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        virtual\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external virtual view returns (uint256);\n\n    function balanceOfUnderlying(address owner)\n        external\n        virtual\n        returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        virtual\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external virtual view returns (uint256);\n\n    function supplyRatePerBlock() external virtual view returns (uint256);\n\n    function totalBorrowsCurrent() external virtual returns (uint256);\n\n    function borrowBalanceCurrent(address account)\n        external\n        virtual\n        returns (uint256);\n\n    function borrowBalanceStored(address account)\n        public\n        virtual\n        view\n        returns (uint256);\n\n    function exchangeRateCurrent() public virtual returns (uint256);\n\n    function exchangeRateStored() public virtual view returns (uint256);\n\n    function getCash() external virtual view returns (uint256);\n\n    function accrueInterest() public virtual returns (uint256);\n\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external virtual returns (uint256);\n\n    /*** Admin Functions ***/\n\n    function _setPendingAdmin(address payable newPendingAdmin)\n        external\n        virtual\n        returns (uint256);\n\n    function _acceptAdmin() external virtual returns (uint256);\n\n    function _setComptroller(ComptrollerInterface newComptroller)\n        public\n        virtual\n        returns (uint256);\n\n    function _setReserveFactor(uint256 newReserveFactorMantissa)\n        external\n        virtual\n        returns (uint256);\n\n    function _reduceReserves(uint256 reduceAmount)\n        external\n        virtual\n        returns (uint256);\n\n    function _setInterestRateModel(InterestRateModel newInterestRateModel)\n        public\n        virtual\n        returns (uint256);\n}\n\ncontract CErc20Storage {\n    /**\n     * @notice Underlying asset for this CToken\n     */\n    address public underlying;\n}\n\nabstract contract CErc20Interface is CErc20Storage {\n    /*** User Interface ***/\n\n    function mint(uint256 mintAmount) external virtual returns (uint256);\n\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount)\n        external\n        virtual\n        returns (uint256);\n\n    function borrow(uint256 borrowAmount) external virtual returns (uint256);\n\n    function repayBorrow(uint256 repayAmount)\n        external\n        virtual\n        returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        virtual\n        returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) external virtual returns (uint256);\n\n    /*** Admin Functions ***/\n\n    function _addReserves(uint256 addAmount) external virtual returns (uint256);\n}\n\ncontract CDelegationStorage {\n    /**\n     * @notice Implementation address for this contract\n     */\n    address public implementation;\n}\n\nabstract contract CDelegatorInterface is CDelegationStorage {\n    /**\n     * @notice Emitted when implementation is changed\n     */\n    event NewImplementation(\n        address oldImplementation,\n        address newImplementation\n    );\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n    function _setImplementation(\n        address implementation_,\n        bool allowResign,\n        bytes memory becomeImplementationData\n    ) public virtual;\n}\n\nabstract contract CDelegateInterface is CDelegationStorage {\n    /**\n     * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n    function _becomeImplementation(bytes memory data) public virtual;\n\n    /**\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n    function _resignImplementation() public virtual;\n}\n"
    },
    "contracts/compound/ComptrollerInterface.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nabstract contract ComptrollerInterface {\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    bool public constant isComptroller = true;\n\n    struct Market {\n\n        bool isListed;\n\n        uint256 collateralFactorMantissa;\n\n        mapping(address => bool) accountMembership;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /*** Assets You Are In ***/\n\n    function enterMarkets(address[] calldata cTokens)\n        external\n        virtual\n        returns (uint256[] memory);\n\n    function exitMarket(address cToken) external virtual returns (uint256);\n\n    /*** Policy Hooks ***/\n\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external virtual returns (uint256);\n\n    function mintVerify(\n        address cToken,\n        address minter,\n        uint256 mintAmount,\n        uint256 mintTokens\n    ) external virtual;\n\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external virtual returns (uint256);\n\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external virtual;\n\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external virtual returns (uint256);\n\n    function borrowVerify(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external virtual;\n\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external virtual returns (uint256);\n\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 borrowerIndex\n    ) external virtual;\n\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external virtual returns (uint256);\n\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    ) external virtual;\n\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external virtual returns (uint256);\n\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external virtual;\n\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external virtual returns (uint256);\n\n    function transferVerify(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external virtual;\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 repayAmount\n    ) external virtual view returns (uint256, uint256);\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/compound/InterestRateModel.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\ninterface InterestRateModel {\n    /**\n     * @notice Calculates the current borrow interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256);\n\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/CDaiKeeper.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./compound/CToken.sol\";\nimport \"./Exponential.sol\";\nimport \"./compound/ComptrollerInterface.sol\";\nimport \"./uniswap/UniswapExchangeInterface.sol\";\n\nimport \"./Keeper.sol\";\nimport \"./CDaiVault.sol\";\nimport \"./CompoundCore.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract CDaiKeeper is CompoundCore, Keeper {\n    using SafeMath for uint256;\n\n    CToken private cdai;\n    ERC20 private dai;\n    ComptrollerInterface private comptroller;\n    ERC20 private comp;\n    UniswapExchangeInterface private daiCompPool;\n\n    uint256 constant safeMaxRatio = 0.999e18;\n\n    string constant CANNOT_REBALANCE = \"cannot rebalance when the collateral ratio is within range\";\n    string constant NO_DAI_AVAILABLE = \"no DAI is available for withdrawal\";\n\n    /// Minimum amount needed to recycle (1000 DAI)\n    uint256 public recycleThreshold = 1000e18;\n\n    event Repay(\n        uint256 indexed amountRepaid,\n        uint256 indexed newDaiHeld,\n        uint256 indexed newDaiOwed\n    );\n\n    event Borrow(uint256 indexed newDaiHeld, uint256 indexed newDaiOwed);\n\n    constructor(\n        address cdaiAddress,\n        address daiAddress,\n        address compAddress,\n        address comptrollerAddress,\n        address daiCompPoolAddress\n    ) CompoundCore(cdaiAddress, comptrollerAddress) {\n        cdai = CToken(cdaiAddress);\n        dai = ERC20(daiAddress);\n        comp = ERC20(compAddress);\n        comptroller = ComptrollerInterface(comptrollerAddress);\n        daiCompPool = UniswapExchangeInterface(daiCompPoolAddress);\n    }\n\n    /**\n     * This sells our COMP tokens to DAI through Uniswap\n     *\n     * @param minDai is the minimum amount of DAI we want in exchange for our COMP\n     */\n    function sellComp(uint256 minDai) internal returns (uint256) {\n        uint256 compBalance = comp.balanceOf(msg.sender);\n        if (compBalance == 0) {\n            return 0;\n        }\n        // we can safely ignore the amount of dai bought returned\n        return\n            daiCompPool.tokenToTokenSwapInput(\n                compBalance,\n                minDai,\n                0,\n                block.timestamp + 1,\n                address(dai)\n            );\n    }\n\n    function isWithinBorrowRatioTarget(\n        uint256 currentBorrowRatio,\n        uint256 targetBorrowRatio,\n        uint256 borrowRatioEpsilon\n    ) internal pure returns (bool) {\n        if (currentBorrowRatio > targetBorrowRatio) {\n            return currentBorrowRatio - targetBorrowRatio <= borrowRatioEpsilon;\n        } else {\n            return targetBorrowRatio - currentBorrowRatio <= borrowRatioEpsilon;\n        }\n    }\n\n    function borrowDai(\n        uint256 _currentBorrowRatio,\n        uint256 _targetBorrowRatio,\n        uint256 _borrowRatioEpsilon\n    ) internal {\n        uint256 _maxAvailableDAI = cdai.getCash();\n        require(_maxAvailableDAI > 0, NO_DAI_AVAILABLE);\n\n        (\n            uint256 _oErr,\n            uint256 _cdaiHeld, // units of cdai\n            uint256 _daiOwed, // units of dai\n            uint256 _exchangeRate\n        ) = cdai.getAccountSnapshot(msg.sender);\n        require(_oErr == 0, \"getAccountSnapshot failed\");\n\n        uint256 _daiHeld = cdaiToDai(_cdaiHeld, _exchangeRate);\n\n        uint256 _collateralFactor = getCdaiCollateralFactor();\n\n        uint256 _scaledSafeMaxRatio = mustMulExp(\n            safeMaxRatio,\n            _collateralFactor\n        );\n\n        uint256 _scaledTargetBorrowRatio = mustMulExp(\n            _targetBorrowRatio,\n            _collateralFactor\n        );\n\n        while (\n            !isWithinBorrowRatioTarget(\n                _currentBorrowRatio,\n                _scaledTargetBorrowRatio,\n                _borrowRatioEpsilon\n            )\n        ) {\n            // take identity scaledSafeMaxRatio = (daiOwed + daiToBorrow) / daiHeld), solve for daiToBorrow\n            uint256 _daiToBorrow = mustMulExp(_scaledSafeMaxRatio, _daiHeld)\n                .sub(_daiOwed);\n\n            // _nextBorrowRatio in [0, 0.75]\n            uint256 _nextBorrowRatio = mustDivExp(\n                _daiOwed.add(_daiToBorrow),\n                _daiHeld.add(_daiToBorrow)\n            );\n\n            // check if this should be the last loop, if so, attain the target\n            if (_nextBorrowRatio > _scaledTargetBorrowRatio) {\n                // we want: R_final = T\n                // T = collateral factor * target\n                // R_final = (B + ÎB) / (H + ÎB)\n                // ÎB = (T * H - B) / (1 - T)\n                _daiToBorrow = mustDivExp(\n                    mustMulExp(_scaledTargetBorrowRatio, _daiHeld).sub(\n                        _daiOwed\n                    ),\n                    expScale - _scaledTargetBorrowRatio\n                );\n            }\n\n            if (_daiToBorrow > _maxAvailableDAI) {\n                _daiToBorrow = _maxAvailableDAI;\n            }\n\n            uint256 _err = cdai.borrow(_daiToBorrow);\n            require(_err == 0, \"dai borrow failed\");\n\n            dai.approve(address(cdai), _daiToBorrow);\n\n            _err = cdai.mint(_daiToBorrow);\n            require(_err == 0, \"cdai mint failed\");\n\n            _daiHeld += _daiToBorrow;\n            _daiOwed += _daiToBorrow;\n            _currentBorrowRatio = mustDivExp(_daiOwed, _daiHeld);\n        }\n        emit Borrow(_daiHeld, _daiOwed);\n    }\n\n    /**\n     * Repays DAI borrow to Compound\n     */\n    function repayDai(\n        uint256 _currentBorrowRatio,\n        uint256 _targetBorrowRatio,\n        uint256 _borrowRatioEpsilon\n    ) internal {\n        uint256 _maxAvailableDAI = cdai.getCash();\n        require(_maxAvailableDAI > 0, NO_DAI_AVAILABLE);\n\n        (\n            uint256 _oErr,\n            uint256 _cdaiHeld, // units of cdai\n            uint256 _daiOwed, // units of dai\n            uint256 _exchangeRate\n        ) = cdai.getAccountSnapshot(msg.sender);\n        require(_oErr == 0, \"getAccountSnapshot failed\");\n\n        uint256 _daiHeld = cdaiToDai(_cdaiHeld, _exchangeRate);\n\n        uint256 _collateralFactor = getCdaiCollateralFactor();\n\n        uint256 _scaledSafeMaxRatio = mustMulExp(\n            safeMaxRatio,\n            _collateralFactor\n        );\n        uint256 _scaledTargetBorrowRatio = mustMulExp(\n            _targetBorrowRatio,\n            _collateralFactor\n        );\n\n        _currentBorrowRatio = mustMulExp(\n            _currentBorrowRatio,\n            _collateralFactor\n        );\n\n        uint256 _totalAmountRepaid = 0;\n        while (\n            !isWithinBorrowRatioTarget(\n                _currentBorrowRatio,\n                _scaledTargetBorrowRatio,\n                _borrowRatioEpsilon\n            )\n        ) {\n            // take identity scaledSafeMaxRatio = daiHeld / (daiOwed - daiToRepay), solve for daiToRepay\n            uint256 _daiToRepay = _daiHeld.sub(\n                mustDivExp(_daiOwed, _scaledSafeMaxRatio)\n            );\n\n            // _nextBorrowRatio in [0, 0.75]\n            uint256 _nextBorrowRatio = mustDivExp(\n                _daiOwed.sub(_daiToRepay),\n                _daiHeld.sub(_daiToRepay)\n            );\n\n            // check if this should be the last loop, if so, attain the target\n            if (_nextBorrowRatio < _scaledTargetBorrowRatio) {\n                // we want: R_final = T\n                // T = collateral factor * target\n                // R_final = (B - ÎB) / (H - ÎB)\n                // ÎB = (RH-B)/ (R-1) = (B-RH) / (1-R)\n                _daiToRepay = mustDivExp(\n                    _daiOwed - mustMulExp(_scaledTargetBorrowRatio, _daiHeld),\n                    expScale - _scaledTargetBorrowRatio\n                );\n            }\n\n            if (_daiToRepay > _maxAvailableDAI) {\n                _daiToRepay = _maxAvailableDAI;\n            }\n\n            uint256 _err = cdai.redeemUnderlying(_daiToRepay);\n            require(_err == 0, \"redeemUnderlying failed\");\n\n            _err = cdai.repayBorrow(_daiToRepay);\n            require(_err == 0, \"repayBorrow failed\");\n\n            _totalAmountRepaid += _daiToRepay;\n\n            _daiHeld -= _daiToRepay;\n            _daiOwed -= _daiToRepay;\n            _currentBorrowRatio = mustDivExp(_daiOwed, _daiHeld);\n        }\n\n        emit Repay(_totalAmountRepaid, _daiHeld, _daiOwed);\n    }\n\n    /**\n     * Supplies all our DAI to Compound cDAI pool\n     */\n    function supplyDai() internal {\n        uint256 daiBalance = dai.balanceOf(msg.sender);\n        if (daiBalance == 0) {\n            return;\n        }\n        dai.approve(address(cdai), daiBalance);\n        uint256 error = cdai.mint(daiBalance);\n        require(error == 0, \"supplyDai: mint failed\");\n    }\n\n    function computeCdaiTarget(\n        uint256 tokensHeld,\n        uint256 targetBorrowRatio,\n        uint256 collateralFactor\n    ) internal pure returns (uint256) {\n        // cdaiTarget = (targetBorrowRatio * tokensHeld * collateralFactor)\n        return mustMulExp3(targetBorrowRatio, tokensHeld, collateralFactor);\n    }\n\n    function cdaiToDai(uint256 cdaiAmount, uint256 exchangeRate)\n        internal\n        pure\n        returns (uint256)\n    {\n        return mustDivExp(cdaiAmount, exchangeRate);\n    }\n\n    /**\n     * Rebalances the assets\n     * Only executes if the current borrow ratio is below the minimum borrow\n     * ratio or above the target borrow ratio\n     * After the rebalance, the borrow ratio should be equal to the target borrow ratio\n     * @param _minBorrowRatio the minimum ratio to be borrowed between 0 to 1\n     * @param _targetBorrowRatio the target ratio to be borrowed between 0 to 1\n     * @param _maxBorrowRatio the maximum ratio to be borrowed between 0 to 1\n     * @param _minimumDaiIncrease is the minimum amount of DAI to get in exchange for COMP tokens\n     */\n    function rebalance(\n        uint256 _minBorrowRatio,\n        uint256 _targetBorrowRatio,\n        uint256 _maxBorrowRatio,\n        uint256 _borrowRatioEpsilon,\n        uint256 _minimumDaiIncrease\n    ) external override {\n        // TODO: check which contract is interacting with Compound\n        // and send the cDAI back to the vault\n        sellComp(_minimumDaiIncrease);\n        supplyDai();\n\n        uint256 _currentBorrowRatio = computeBorrowRatio(msg.sender);\n\n        if (_currentBorrowRatio < _minBorrowRatio) {\n            borrowDai(\n                _currentBorrowRatio,\n                _targetBorrowRatio,\n                _borrowRatioEpsilon\n            );\n        } else if (_currentBorrowRatio > _maxBorrowRatio) {\n            repayDai(\n                _currentBorrowRatio,\n                _targetBorrowRatio,\n                _borrowRatioEpsilon\n            );\n        } else {\n            revert(CANNOT_REBALANCE);\n        }\n    }\n}\n"
    },
    "contracts/compound/CToken.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"./CTokenInterfaces.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\nabstract contract CToken is CTokenInterface, CErc20Interface {\n\n}\n"
    },
    "contracts/Exponential.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"./compound/Exponential.sol\" as E;\n\ncontract Exponential is E.Exponential {\n    function mustMulExp(uint256 a, uint256 b) internal pure returns (uint256) {\n        (MathError err, Exp memory result) = mulExp(a, b);\n        require(err == MathError.NO_ERROR, \"math failed\");\n        return result.mantissa;\n    }\n\n    function mustMulExp3(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (uint256) {\n        return mustMulExp(mustMulExp(a, b), c);\n    }\n\n    function mustDivExp(uint256 a, uint256 b) internal pure returns (uint256) {\n        (MathError err, Exp memory result) = divExp(\n            Exp({mantissa: a}),\n            Exp({mantissa: b})\n        );\n        require(err == MathError.NO_ERROR, \"math failed\");\n        return result.mantissa;\n    }\n}\n"
    },
    "contracts/uniswap/UniswapExchangeInterface.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\ninterface UniswapExchangeInterface {\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress() external view returns (address token);\n\n    // Address of Uniswap Factory\n    function factoryAddress() external view returns (address factory);\n\n    // Provide Liquidity\n    function addLiquidity(\n        uint256 min_liquidity,\n        uint256 max_tokens,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256 min_eth,\n        uint256 min_tokens,\n        uint256 deadline\n    ) external returns (uint256, uint256);\n\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold)\n        external\n        view\n        returns (uint256 tokens_bought);\n\n    function getEthToTokenOutputPrice(uint256 tokens_bought)\n        external\n        view\n        returns (uint256 eth_sold);\n\n    function getTokenToEthInputPrice(uint256 tokens_sold)\n        external\n        view\n        returns (uint256 eth_bought);\n\n    function getTokenToEthOutputPrice(uint256 eth_bought)\n        external\n        view\n        returns (uint256 tokens_sold);\n\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)\n        external\n        payable\n        returns (uint256 tokens_bought);\n\n    function ethToTokenTransferInput(\n        uint256 min_tokens,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256 tokens_bought);\n\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline)\n        external\n        payable\n        returns (uint256 eth_sold);\n\n    function ethToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256 eth_sold);\n\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline\n    ) external returns (uint256 eth_bought);\n\n    function tokenToEthTransferInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline,\n        address recipient\n    ) external returns (uint256 eth_bought);\n\n    function tokenToEthSwapOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline\n    ) external returns (uint256 tokens_sold);\n\n    function tokenToEthTransferOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline,\n        address recipient\n    ) external returns (uint256 tokens_sold);\n\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address token_addr\n    ) external returns (uint256 tokens_bought);\n\n    function tokenToTokenTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external returns (uint256 tokens_bought);\n\n    function tokenToTokenSwapOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address token_addr\n    ) external returns (uint256 tokens_sold);\n\n    function tokenToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external returns (uint256 tokens_sold);\n\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address exchange_addr\n    ) external returns (uint256 tokens_bought);\n\n    function tokenToExchangeTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address exchange_addr\n    ) external returns (uint256 tokens_bought);\n\n    function tokenToExchangeSwapOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address exchange_addr\n    ) external returns (uint256 tokens_sold);\n\n    function tokenToExchangeTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address exchange_addr\n    ) external returns (uint256 tokens_sold);\n\n    // ERC20 comaptibility for liquidity tokens\n    function name() external returns (bytes32);\n\n    function symbol() external returns (bytes32);\n\n    function decimals() external returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 value\n    ) external returns (bool);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    // Never use\n    function setup(address token_addr) external;\n}\n"
    },
    "contracts/CDaiVault.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./compound/CTokenInterfaces.sol\";\nimport \"./compound/ComptrollerInterface.sol\";\nimport \"./Keeper.sol\";\nimport \"./Exponential.sol\";\nimport \"./CompoundCore.sol\";\nimport \"./Ownable.sol\";\nimport \"./compound/UniswapAnchoredView.sol\";\n\ncontract CDaiVault is CompoundCore, Ownable, ERC20 {\n    using SafeMath for uint256;\n\n    CTokenInterface private cdai;\n    ERC20 private dai;\n    ComptrollerInterface private comptroller;\n    UniswapAnchoredView private uniswapanchor;\n    ERC20 private comp;\n\n    struct BorrowRatio {\n        uint256 minimum;\n        uint256 target;\n        uint256 maximum;\n        uint256 epsilon;\n    }\n    uint256 constant slippageRatio = 0.97e18;\n\n    BorrowRatio public intendedBorrowRatio;\n\n    constructor(\n        address _cdaiAddress,\n        address _comptrollerAddress,\n        address _compUniswapAnchorAddress\n    ) ERC20(\"Vault DAI\", \"vDAI\") CompoundCore(_cdaiAddress, _comptrollerAddress) {\n        intendedBorrowRatio.minimum = 0.95e18;\n        intendedBorrowRatio.target = 0.97e18;\n        intendedBorrowRatio.maximum = 0.99e18;\n        intendedBorrowRatio.epsilon = 0.005e18;\n\n        uniswapanchor = UniswapAnchoredView(_compUniswapAnchorAddress);\n    }\n\n    // constructor (address _cdai, address _dai, address _controller) public ERC20Detailed(\n    //     string(abi.encodePacked(\"yearn \", ERC20Detailed(_token).name())),\n    //     string(abi.encodePacked(\"y\", ERC20Detailed(_token).symbol())),\n    //     ERC20Detailed(_token).decimals()\n    // ) {\n    //     cdai = CTokenInterface(_cdai);\n    //     dai = ERC20(_dai);\n    //     governance = msg.sender;\n    //     controller = _controller;\n    // }\n\n    /**\n     * Calculate the net asset value of the entire vault\n     * @return nav in units of cDai\n     */\n    function nav() internal view returns (uint256) {\n        (\n            uint256 oErr,\n            uint256 cdaiHeld, // units of cdai\n            uint256 daiOwed, // units of dai\n            uint256 exchangeRate\n        ) = cdai.getAccountSnapshot(address(this));\n        require(oErr == 0, \"nav: getAccountSnapshot failed\");\n        return cdaiHeld.sub(mustMulExp(daiOwed, exchangeRate));\n    }\n\n    /**\n     * Calculate the net asset value of the entire vault\n     * @return nav in units of cDai\n     */\n    function nav(\n        uint256 cdaiHeld,\n        uint256 daiOwed,\n        uint256 exchangeRate\n    ) internal pure returns (uint256) {\n        return cdaiHeld.sub(mustMulExp(daiOwed, exchangeRate));\n    }\n\n    /**\n     * Deposit funds\n     * Given an input amount of cDai, return the corresponding vdai\n     * @param _amount the number of cDai tokens to deposit\n     */\n    function deposit(uint256 _amount) public {\n        bool success = cdai.transferFrom(msg.sender, address(this), _amount);\n        require(success, \"cdai transfer failed\");\n\n        uint256 shares = 0; //vdai\n        uint256 currentSupply = totalSupply(); //vdai\n        if (currentSupply == 0) {\n            shares = _amount;\n        } else {\n            uint256 _nav = nav();\n            // nav / currentSupply == amount / share\n            // share == amount * currentSupply / nav\n            shares = mustDivExp(mustMulExp(_amount, currentSupply), _nav);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    /**\n     * Withdraws the deposited funds\n     * Given an input amount of vdai, return the corresponding cdai\n     * @param _shares the number of vdai tokens held\n     */\n    function withdraw(uint256 _shares) external {\n        withdraw(_shares, address(0x0));\n    }\n\n    struct withdrawLocalVars {\n        uint256 err;\n        uint256 cdaiHeld;\n        uint256 daiOwed;\n        uint256 daiCdaiExchangeRate;\n        uint256 nav;\n        uint256 cdaiToWithdraw;\n        uint256 percentShares;\n        uint256 collateralFactor;\n        uint256 scalingFactor;\n    }\n\n    function withdraw(uint256 _sharesToRedeem, address _keeperAddress) public {\n        withdrawLocalVars memory vars;\n\n        (\n            vars.err,\n            vars.cdaiHeld, // units of cdai\n            vars.daiOwed, // units of dai\n            vars.daiCdaiExchangeRate\n        ) = cdai.getAccountSnapshot(address(this));\n        require(vars.err == 0, \"rebalance: getAccountSnapshot failed\");\n\n        // NOTE: this value does not take into account potential COMP held\n        vars.nav = nav(vars.cdaiHeld, vars.daiOwed, vars.daiCdaiExchangeRate);\n        vars.cdaiToWithdraw = mustDivExp(mustMulExp(vars.nav, _sharesToRedeem), totalSupply());\n        _burn(msg.sender, _sharesToRedeem);\n\n        BorrowRatio memory _intendedBorrowRatio = intendedBorrowRatio;\n\n        vars.percentShares = mustDivExp(_sharesToRedeem, totalSupply());\n        //Units: [0,1], typically around 0.75 scaled with 1e18\n        vars.collateralFactor = getCdaiCollateralFactor();\n\n        // scalingFactor calculates modified target, taking into account that we need cdaiToWithdraw = slack level. After final withdrawal, will achieve target\n        // scalingFactor = 1 / (1 + percentShares * (1-Target))\n        // derived from NAV def (constant across steps per share) = dai supplied - dai borrowed (at end or start),\n        // share value in dai = percentShares * NAV,\n        // identity target = dai borrow at end / dai supplied at end,\n        // and identity modified target = dai borrow at end / (dai supplied at end + share value in Dai)\n        vars.scalingFactor = mustDivExp(\n            expScale,\n            (expScale +\n                mustMulExp(\n                    vars.percentShares,\n                    expScale - mustMulExp(_intendedBorrowRatio.target, vars.collateralFactor)\n                ))\n        );\n\n        //Units: [0,1]\n        uint256 _borrowRatio =\n            computeBorrowRatio(\n                vars.cdaiHeld,\n                vars.daiOwed,\n                vars.daiCdaiExchangeRate,\n                vars.collateralFactor\n            );\n\n        //Units: [0,1]\n        uint256 _slack = 0;\n        if (_borrowRatio < _intendedBorrowRatio.maximum) {\n            _slack = _intendedBorrowRatio.maximum.sub(_borrowRatio);\n        }\n\n        //Units: cdai tokens (e.g., 1000)\n        uint256 _cdaiSlack = mustMulExp3(_slack, vars.collateralFactor, vars.cdaiHeld);\n\n        uint256 compPriceInDai =\n            mustDivExp(uniswapanchor.price(\"COMP\"), uniswapanchor.price(\"DAI\"));\n\n        // COMP->Dai price * COMP held * (1-slippage factor)\n        uint256 _compDaiValue =\n            mustMulExp3(comp.balanceOf(msg.sender), compPriceInDai, slippageRatio);\n\n        if (_cdaiSlack < vars.cdaiToWithdraw) {\n            require(\n                _keeperAddress != address(0x0),\n                \"rebalancing required but no keeper address provided\"\n            );\n\n            // TODO: check if this reverts automatically or not\n            // TO-REMEBER: This could be optimized in the future by potentially passing more arguments\n            Keeper(_keeperAddress).rebalance(\n                mustMulExp(vars.scalingFactor, _intendedBorrowRatio.minimum),\n                mustMulExp(vars.scalingFactor, _intendedBorrowRatio.target),\n                mustMulExp(vars.scalingFactor, _intendedBorrowRatio.maximum),\n                _intendedBorrowRatio.epsilon,\n                _compDaiValue\n            );\n        }\n\n        // check NAV\n        //old NAV/share = _nav / (totalsupply() + sharesToRedeem)\n        uint256 oldNavPerShare = mustDivExp(vars.nav, (totalSupply().add(_sharesToRedeem)));\n\n        (\n            vars.err,\n            vars.cdaiHeld, // units of cdai\n            vars.daiOwed, // units of dai\n            vars.daiCdaiExchangeRate\n        ) = cdai.getAccountSnapshot(address(this));\n        require(vars.err == 0, \"rebalance: getAccountSnapshot failed\");\n\n        // check old NAV/share - new NAV/share increases by at least _compDaiValue/totalsupply()\n        uint256 newNavPerShare =\n            mustDivExp(nav(vars.cdaiHeld, vars.daiOwed, vars.daiCdaiExchangeRate), totalSupply());\n        require(\n            newNavPerShare.sub(oldNavPerShare) > mustDivExp(_compDaiValue, totalSupply()),\n            \"Keeper returned insufficient NAV/share.\"\n        );\n\n        // check leverage (post-withdraw)\n        //Units: [0,1]\n        _borrowRatio = computeBorrowRatio(\n            vars.cdaiHeld,\n            vars.daiOwed,\n            vars.daiCdaiExchangeRate,\n            vars.collateralFactor\n        );\n        uint256 _scaledTargetBorrowRatio =\n            mustMulExp(vars.scalingFactor, intendedBorrowRatio.target);\n        // check currentBorrowRatio (pre-withdraw) within epsilon of scalingFactor * indendedBorrowRatio.target\n        if (_borrowRatio > _scaledTargetBorrowRatio) {\n            require(\n                _borrowRatio - _scaledTargetBorrowRatio < intendedBorrowRatio.epsilon,\n                \"Keeper returned insufficient borrow ratio.\"\n            );\n        } else {\n            require(\n                _scaledTargetBorrowRatio - _borrowRatio < intendedBorrowRatio.epsilon,\n                \"Keeper returned insufficient borrow ratio.\"\n            );\n        }\n        // should be same as checking currentBorrowRatio (post-withdraw) within epsilon of intendedBorrowRatio.target\n\n        cdai.transfer(msg.sender, vars.cdaiToWithdraw);\n    }\n\n    fallback() external {\n        revert(\"fallback function should not be called\");\n    }\n\n    function rebalance(address _keeperAddress) public {\n        (\n            uint256 _oErr,\n            uint256 _cdaiHeld, // units of cdai\n            uint256 _daiOwed, // units of dai\n            uint256 _daiCdaiExchangeRate\n        ) = cdai.getAccountSnapshot(address(this));\n        require(_oErr == 0, \"rebalance: getAccountSnapshot failed\");\n\n        // NOTE: this value does not take into account potential COMP held\n        uint256 _nav = nav(_cdaiHeld, _daiOwed, _daiCdaiExchangeRate);\n\n        BorrowRatio memory _intendedBorrowRatio = intendedBorrowRatio;\n\n        //Units: [0,1], typically around 0.75 scaled with 1e18\n        uint256 _collateralFactor = getCdaiCollateralFactor();\n\n        //Units: [0,1]\n        uint256 _borrowRatio =\n            computeBorrowRatio(_cdaiHeld, _daiOwed, _daiCdaiExchangeRate, _collateralFactor);\n\n        // COMP->Dai price * COMP held * (1-slippage factor)\n        uint256 _compDaiValue =\n            mustMulExp3(\n                comp.balanceOf(msg.sender),\n                mustDivExp(uniswapanchor.price(\"COMP\"), uniswapanchor.price(\"DAI\")), // comp price in DAI\n                slippageRatio\n            );\n\n        // TODO: check if this reverts automatically or not\n        // TO-REMEBER: This could be optimized in the future by potentially passing more arguments\n        Keeper(_keeperAddress).rebalance(\n            _intendedBorrowRatio.minimum,\n            _intendedBorrowRatio.target,\n            _intendedBorrowRatio.maximum,\n            _intendedBorrowRatio.epsilon,\n            _compDaiValue\n        );\n\n        // check NAV\n        //old NAV/share = _nav / (totalsupply() + sharesToRedeem)\n        uint256 oldNavPerShare = mustDivExp(_nav, totalSupply());\n\n        (\n            _oErr,\n            _cdaiHeld, // units of cdai\n            _daiOwed, // units of dai\n            _daiCdaiExchangeRate\n        ) = cdai.getAccountSnapshot(address(this));\n        require(_oErr == 0, \"rebalance: getAccountSnapshot failed\");\n\n        // check old NAV/share - new NAV/share increases by at least _compDaiValue/totalsupply()\n        uint256 newNavPerShare =\n            mustDivExp(nav(_cdaiHeld, _daiOwed, _daiCdaiExchangeRate), totalSupply());\n        require(\n            newNavPerShare.sub(oldNavPerShare) > mustDivExp(_compDaiValue, totalSupply()),\n            \"Keeper returned insufficient NAV/share.\"\n        );\n\n        // check leverage (post-withdraw)\n        //Units: [0,1]\n        _borrowRatio = computeBorrowRatio(\n            _cdaiHeld,\n            _daiOwed,\n            _daiCdaiExchangeRate,\n            _collateralFactor\n        );\n        if (_borrowRatio > _intendedBorrowRatio.target) {\n            require(\n                _borrowRatio - _intendedBorrowRatio.target < intendedBorrowRatio.epsilon,\n                \"Keeper returned insufficient borrow ratio.\"\n            );\n        } else {\n            require(\n                _intendedBorrowRatio.target - _borrowRatio < intendedBorrowRatio.epsilon,\n                \"Keeper returned insufficient borrow ratio.\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/CompoundCore.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"./Exponential.sol\";\nimport \"./compound/CTokenInterfaces.sol\";\nimport \"./compound/ComptrollerInterface.sol\";\n\ncontract CompoundCore is Exponential {\n    CTokenInterface private cdai;\n    ComptrollerInterface private comptroller;\n\n    constructor(address cdaiAddress, address comptrollerAddress) {\n        cdai = CTokenInterface(cdaiAddress);\n        comptroller = ComptrollerInterface(comptrollerAddress);\n    }\n\n    /**\n     * Gets the collateral factor from Compound for cDai\n     * Given an input amount of vdai, return the corresponding cdai\n     * @return result in interval [0,1]\n     */\n    function getCdaiCollateralFactor() public view returns (uint256 result) {\n        (bool listed, uint256 collateralFactor) = comptroller.markets(\n            address(cdai)\n        );\n        require(listed, \"cdai market is not listed\");\n        return collateralFactor;\n    }\n\n    function computeBorrowRatio(address account) internal view returns (uint256) {\n        (\n            uint256 _oErr,\n            uint256 _cdaiHeld, // units of cdai\n            uint256 _daiOwed, // units of dai\n            uint256 _exchangeRate\n        ) = cdai.getAccountSnapshot(account);\n        uint256 _collateralFactor = getCdaiCollateralFactor();\n        require(_oErr == 0, \"computeBorrowRatio: getAccountSnapshot failed\");\n        return computeBorrowRatio(_cdaiHeld, _daiOwed, _exchangeRate, _collateralFactor);\n    }\n\n    /**\n     * Computes the collateral ratio of the keeper\n     * This function already takes into account the collateral factor\n     * given collateral factor = 0.75, supplied = 100 and borrowed = 75\n     * the result will be 1\n     * @param _cdaiHeld amount of tokens held, in cToken\n     * @param _daiOwed amount of tokens owed, in underlying currency\n     * @param _daiCdaiExchangeRate is the exchange rate from the underlying to the cToken, dai -> cDai\n     * @param _collateralFactor collateral factor from cToken to underlying between 0 and 1\n     * @return the borrow ratio from 0 to 1, with 1 meaning we cannot borrow more without getting liquidated\n     */\n    function computeBorrowRatio(\n        uint256 _cdaiHeld,\n        uint256 _daiOwed,\n        uint256 _daiCdaiExchangeRate,\n        uint256 _collateralFactor\n    ) internal pure returns (uint256) {\n        // floor(floor(daiOwed * exchangeRate) / floor(cdaiHeld * collateralFactor))\n        return\n            mustDivExp(\n                mustMulExp(_daiOwed, _daiCdaiExchangeRate), // convert dai to cdai\n                mustMulExp(_cdaiHeld, _collateralFactor) // take the collateral factor into account\n            );\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.8.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logByte(byte p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(byte)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/compound/Exponential.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"./CarefulMath.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath {\n    uint256 constant expScale = 1e18;\n    uint256 constant doubleScale = 1e36;\n    uint256 constant halfExpScale = expScale / 2;\n    uint256 constant mantissaOne = expScale;\n\n    struct Exp {\n        uint256 mantissa;\n    }\n\n    struct Double {\n        uint256 mantissa;\n    }\n\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint256 num, uint256 denom)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(\n        Exp memory a,\n        uint256 scalar,\n        uint256 addend\n    ) internal pure returns (MathError, uint256) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 descaledMantissa) = divUInt(\n            a.mantissa,\n            scalar\n        );\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint256 scalar, Exp memory divisor)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 doubleScaledProduct) = mulUInt(\n            a.mantissa,\n            b.mantissa\n        );\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(\n            halfExpScale,\n            doubleScaledProduct\n        );\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint256 product) = divUInt(\n            doubleScaledProductWithHalfScale,\n            expScale\n        );\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(\n        Exp memory a,\n        Exp memory b,\n        Exp memory c\n    ) internal pure returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        return getExp(a.mantissa, b.mantissa);\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) internal pure returns (uint256) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint224)\n    {\n        require(n < 2**224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint32)\n    {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return\n            Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint256 a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n"
    },
    "contracts/compound/CarefulMath.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n     * @dev Multiplies two numbers, returns an error on overflow.\n     */\n    function mulUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint256 c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function divUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function subUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function addUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        uint256 c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev add a and b and then subtract c\n     */\n    function addThenSubUInt(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (MathError, uint256) {\n        (MathError err0, uint256 sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n"
    },
    "contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function initializeOwner() external {\n        require(_owner == address(0), \"owner already initialized\");\n        _owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/compound/UniswapAnchoredView.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Ownable.sol\";\n\nenum PriceSource {\n    FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\n    FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\n    REPORTER /// implies the price is set by the reporter\n}\n\nstruct TokenConfig {\n    address cToken;\n    address underlying;\n    bytes32 symbolHash;\n    uint256 baseUnit;\n    PriceSource priceSource;\n    uint256 fixedPrice;\n    address uniswapMarket;\n    bool isUniswapReversed;\n}\n\ninterface UniswapAnchoredView {\n    function price(string calldata symbol) external view returns (uint256);\n\n    function getTokenConfigBySymbol(string memory symbol)\n        external\n        view\n        returns (TokenConfig memory);\n}\n\ncontract DummyUniswapAnchoredView is Ownable, UniswapAnchoredView {\n    mapping(string => uint256) private prices;\n    mapping(string => TokenConfig) private tokenConfigs;\n    mapping(string => bool) public tokenRegistered;\n\n    function addToken(string memory symbol, TokenConfig memory config) public onlyOwner {\n        tokenRegistered[symbol] = true;\n        tokenConfigs[symbol] = config;\n    }\n\n    function setPrice(string memory symbol, uint256 _price) public onlyOwner {\n        require(tokenRegistered[symbol], \"symbol not registered\");\n        prices[symbol] = _price;\n    }\n\n    function price(string calldata symbol) external view override returns (uint256) {\n        return prices[symbol];\n    }\n\n    function getTokenConfigBySymbol(string memory symbol)\n        external\n        view\n        override\n        returns (TokenConfig memory)\n    {\n        return tokenConfigs[symbol];\n    }\n}\n"
    },
    "contracts/BPTFund.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./Ownable.sol\";\nimport \"./compound/CTokenInterfaces.sol\";\nimport \"./compound/ComptrollerInterface.sol\";\nimport \"./BPTKeeper.sol\";\nimport \"./Exponential.sol\";\nimport \"./CompoundCore.sol\";\nimport \"./compound/UniswapAnchoredView.sol\";\nimport \"./balancer/BPool.sol\";\n\ncontract BPTFund is Ownable, ERC20, Exponential {\n    using SafeMath for uint256;\n\n    BPool private balancerPool;\n\n    address public balAddress;\n    address public wethAddress;\n\n    struct BorrowRatio {\n        uint256 minimum;\n        uint256 target;\n        uint256 maximum;\n        uint256 epsilon;\n    }\n    uint256 constant slippageRatio = 0.97e18;\n\n    BorrowRatio public intendedBorrowRatio;\n\n    constructor(\n        address _balancerPoolAddress,\n        address _balAddress,\n        address _wethAddress\n    ) ERC20(\"Fund BPT\", \"gBPT\") {\n        balancerPool = BPool(_balancerPoolAddress);\n        balAddress = _balAddress;\n        wethAddress = _wethAddress;\n\n        intendedBorrowRatio.minimum = 0.95e18;\n        intendedBorrowRatio.target = 0.97e18;\n        intendedBorrowRatio.maximum = 0.99e18;\n        intendedBorrowRatio.epsilon = 0.005e18;\n    }\n\n    /**\n     * Calculate the net asset value of the entire vault\n     * @return nav in units of BPT\n     */\n    function nav() internal view returns (uint256) {\n        return balancerPool.balanceOf(address(this));\n    }\n\n    function transferFromSender(uint256 _amount) internal returns (bool _success) {\n        _success = balancerPool.transferFrom(msg.sender, address(this), _amount);\n        return _success;\n    }\n\n    function transferToSender(uint256 _amount) internal returns (bool _success) {\n        _success = balancerPool.transfer(msg.sender, _amount);\n        return _success;\n    }\n\n    /**\n     * Deposit funds\n     * Given an input amount of BPT\n     * @param _amount the number of BP tokens to deposit\n     */\n    function deposit(uint256 _amount) public {\n        bool success = transferFromSender(_amount);\n        require(success, \"transfer from sender failed\");\n\n        uint256 _shares = 0;\n        uint256 _currentSupply = totalSupply();\n        if (_currentSupply == 0) {\n            _shares = _amount;\n        } else {\n            uint256 _nav = nav();\n            // nav / currentSupply == amount / share\n            // share == amount * currentSupply / nav\n            _shares = mustDivExp(mustMulExp(_amount, _currentSupply), _nav);\n        }\n        _mint(msg.sender, _shares);\n    }\n\n    /**\n     * Withdraws the deposited funds\n     * @param _sharesToRedeem is the number of shares to be redeemed\n     */\n    function withdraw(uint256 _sharesToRedeem) external {\n        withdraw(_sharesToRedeem, address(0x0));\n    }\n\n    /**\n     * Withdraws `_sharesToRedeem` from the funds\n     * @param _sharesToRedeem is the number of shares to be redeemed\n     * @dev second parameter needed to comply with the Fund interface but not used here\n     */\n    function withdraw(uint256 _sharesToRedeem, address) public {\n        uint256 _nav = nav();\n        uint256 _amountToWithdraw = mustDivExp(mustMulExp(_nav, _sharesToRedeem), totalSupply());\n        _burn(msg.sender, _sharesToRedeem);\n        transferToSender(_amountToWithdraw);\n    }\n\n    fallback() external {\n        revert(\"fallback function should not be called\");\n    }\n\n    function getPrice()\n        public\n        pure\n        returns (\n            //address _baseAddress, address _quoteAddress)\n            uint256\n        )\n    {\n        return 1;\n    }\n\n    function rebalance(address _keeperAddress) public {\n        // TODO: check that pool is balanced\n        // and find token with highest volume\n        uint256 _highestVolumeTokenIndex = 0;\n\n        uint256 _balBalance = balancerPool.balanceOf(msg.sender);\n\n        uint256 _wethAmount =\n            mustDivExp(\n                _balBalance,\n                getPrice() //(wethAddress, balAddress)\n            );\n\n        address[] memory _tokens = balancerPool.getFinalTokens();\n        uint256 _weight = balancerPool.getNormalizedWeight(_tokens[_highestVolumeTokenIndex]);\n\n        uint256 _outAmount =\n            mustMulExp3(\n                getPrice(), //(wethAddress, _tokens[0]), // TODO: double-check base/quote order\n                _wethAmount,\n                _weight\n            );\n\n        // TODO: make the slippage ratio dependent on the amount of BAL to sell\n        uint256 _poolSupply = balancerPool.totalSupply();\n        uint256 _firstAssetBalance = balancerPool.getBalance(_tokens[_highestVolumeTokenIndex]);\n        uint256 _supplyRatio = mustDivExp(_outAmount, _firstAssetBalance);\n        uint256 _targetAmountOut = mustMulExp3(_supplyRatio, _poolSupply, expScale - slippageRatio);\n        uint256 _currentBalance = balancerPool.balanceOf(address(this));\n        BPTKeeper(_keeperAddress).rebalance();\n        uint256 _newBalance = balancerPool.balanceOf(address(this));\n        require(\n            _currentBalance.add(_targetAmountOut) <= _newBalance,\n            \"keeper did not generate enough BPT\"\n        );\n    }\n}\n"
    },
    "contracts/BPTKeeper.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./Exponential.sol\";\nimport \"./uniswap/UniswapExchangeInterface.sol\";\nimport \"./balancer/BPool.sol\";\n\nimport \"./Keeper.sol\";\nimport \"./CDaiVault.sol\";\nimport \"./Exponential.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract BPTKeeper is Exponential {\n    using SafeMath for uint256;\n\n    uint256 public constant slippage = 0.5e18;\n\n    BPool private balancerPool;\n\n    BPool public ethBalPool;\n\n    address[] public tokenPools;\n\n    address public balAddress;\n    address public wethAddress;\n\n    constructor(\n        address _balancerPoolAddress,\n        address _balAddress,\n        address _wethAddress,\n        address _ethBalPoolAddress,\n        address[] memory _tokenPools\n    ) {\n        balancerPool = BPool(_balancerPoolAddress);\n        address[] memory tokens = balancerPool.getFinalTokens();\n        require(\n            tokens.length == _tokenPools.length,\n            \"_tokenPools should have the same number of tokens as the balancer pool\"\n        );\n        balAddress = _balAddress;\n        wethAddress = _wethAddress;\n        ethBalPool = BPool(_ethBalPoolAddress);\n        tokenPools = _tokenPools;\n    }\n\n    /**\n     * Rebalances the assets\n     */\n    function rebalance() external {\n        // TODO: claim BAL rewards\n        uint256 _balBalance = balancerPool.balanceOf(msg.sender);\n\n        (uint256 _wethAmount, ) = ethBalPool.swapExactAmountIn(\n            balAddress,\n            _balBalance,\n            wethAddress,\n            0,\n            0 // TODO: get this from oracle\n        );\n\n        address[] memory _tokens = balancerPool.getFinalTokens();\n        uint256[] memory _swappedAmounts = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _weight = balancerPool.getNormalizedWeight(_tokens[i]);\n            uint256 _tokenWethAmount = mustMulExp(_wethAmount, _weight);\n            // TODO: check if we want to use uniswap here instead\n            BPool _pool = BPool(tokenPools[i]);\n\n            (uint256 _outAmount, ) = _pool.swapExactAmountIn(\n                wethAddress,\n                _tokenWethAmount,\n                _tokens[i],\n                0,\n                0 // TODO: get this from oracle\n            );\n            _swappedAmounts[i] = _outAmount;\n        }\n\n        uint256 _poolSupply = balancerPool.totalSupply();\n        uint256 _firstAssetBalance = balancerPool.getBalance(_tokens[0]);\n        uint256 _supplyRatio = mustDivExp(\n            _swappedAmounts[0],\n            _firstAssetBalance\n        );\n        uint256 _targetAmountOut = mustMulExp3(\n            _supplyRatio,\n            _poolSupply,\n            expScale - slippage\n        );\n        balancerPool.joinPool(_targetAmountOut, _swappedAmounts);\n\n        balancerPool.transfer(msg.sender, _targetAmountOut);\n    }\n}\n"
    },
    "contracts/balancer/BPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./BToken.sol\";\nimport \"./BMath.sol\";\n\ncontract BPool is BBronze, BToken, BMath {\n    struct Record {\n        bool bound; // is token bound to pool\n        uint256 index; // private\n        uint256 denorm; // denormalized weight\n        uint256 balance;\n    }\n\n    event LOG_SWAP(\n        address indexed caller,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 tokenAmountIn,\n        uint256 tokenAmountOut\n    );\n\n    event LOG_JOIN(\n        address indexed caller,\n        address indexed tokenIn,\n        uint256 tokenAmountIn\n    );\n\n    event LOG_EXIT(\n        address indexed caller,\n        address indexed tokenOut,\n        uint256 tokenAmountOut\n    );\n\n    event LOG_CALL(\n        bytes4 indexed sig,\n        address indexed caller,\n        bytes data\n    ) anonymous;\n\n    modifier _logs_() {\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n        _;\n    }\n\n    modifier _lock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _mutex = true;\n        _;\n        _mutex = false;\n    }\n\n    modifier _viewlock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _;\n    }\n\n    bool private _mutex;\n\n    address private _factory; // BFactory address to push token exitFee to\n    address private _controller; // has CONTROL role\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\n\n    // `setSwapFee` and `finalize` require CONTROL\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\n    uint256 private _swapFee;\n    bool private _finalized;\n\n    address[] private _tokens;\n    mapping(address => Record) private _records;\n    uint256 private _totalWeight;\n\n    constructor() {\n        _controller = msg.sender;\n        _factory = msg.sender;\n        _swapFee = MIN_FEE;\n        _publicSwap = false;\n        _finalized = false;\n    }\n\n    function isPublicSwap() external view returns (bool) {\n        return _publicSwap;\n    }\n\n    function isFinalized() external view returns (bool) {\n        return _finalized;\n    }\n\n    function isBound(address t) external view returns (bool) {\n        return _records[t].bound;\n    }\n\n    function getNumTokens() external view returns (uint256) {\n        return _tokens.length;\n    }\n\n    function getCurrentTokens()\n        external\n        view\n        _viewlock_\n        returns (address[] memory tokens)\n    {\n        return _tokens;\n    }\n\n    function getFinalTokens()\n        external\n        view\n        _viewlock_\n        returns (address[] memory tokens)\n    {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        return _tokens;\n    }\n\n    function getDenormalizedWeight(address token)\n        external\n        view\n        _viewlock_\n        returns (uint256)\n    {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        return _records[token].denorm;\n    }\n\n    function getTotalDenormalizedWeight()\n        external\n        view\n        _viewlock_\n        returns (uint256)\n    {\n        return _totalWeight;\n    }\n\n    function getNormalizedWeight(address token)\n        external\n        view\n        _viewlock_\n        returns (uint256)\n    {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        uint256 denorm = _records[token].denorm;\n        return bdiv(denorm, _totalWeight);\n    }\n\n    function getBalance(address token)\n        external\n        view\n        _viewlock_\n        returns (uint256)\n    {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        return _records[token].balance;\n    }\n\n    function getSwapFee() external view _viewlock_ returns (uint256) {\n        return _swapFee;\n    }\n\n    function getController() external view _viewlock_ returns (address) {\n        return _controller;\n    }\n\n    function setSwapFee(uint256 swapFee) external _logs_ _lock_ {\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\n        require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\n        _swapFee = swapFee;\n    }\n\n    function setController(address manager) external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        _controller = manager;\n    }\n\n    function setPublicSwap(bool public_) external _logs_ _lock_ {\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        _publicSwap = public_;\n    }\n\n    function finalize() external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\n\n        _finalized = true;\n        _publicSwap = true;\n\n        _mintPoolShare(INIT_POOL_SUPPLY);\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\n    }\n\n    function bind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    )\n        external\n        _logs_\n    // _lock_  Bind does not lock because it jumps to `rebind`, which does\n    {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(!_records[token].bound, \"ERR_IS_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        require(_tokens.length < MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\n\n        _records[token] = Record({\n            bound: true,\n            index: _tokens.length,\n            denorm: 0, // balance and denorm will be validated\n            balance: 0 // and set by `rebind`\n        });\n        _tokens.push(token);\n        rebind(token, balance, denorm);\n    }\n\n    function rebind(\n        address token,\n        uint256 balance,\n        uint256 denorm\n    ) public _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\n        require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\n        require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");\n\n        // Adjust the denorm and totalWeight\n        uint256 oldWeight = _records[token].denorm;\n        if (denorm > oldWeight) {\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\n        } else if (denorm < oldWeight) {\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\n        }\n        _records[token].denorm = denorm;\n\n        // Adjust the balance record and actual token balance\n        uint256 oldBalance = _records[token].balance;\n        _records[token].balance = balance;\n        if (balance > oldBalance) {\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\n        } else if (balance < oldBalance) {\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\n            uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\n            uint256 tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\n            _pushUnderlying(\n                token,\n                msg.sender,\n                bsub(tokenBalanceWithdrawn, tokenExitFee)\n            );\n            _pushUnderlying(token, _factory, tokenExitFee);\n        }\n    }\n\n    function unbind(address token) external _logs_ _lock_ {\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        require(!_finalized, \"ERR_IS_FINALIZED\");\n\n        uint256 tokenBalance = _records[token].balance;\n        uint256 tokenExitFee = bmul(tokenBalance, EXIT_FEE);\n\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\n\n        // Swap the token-to-unbind with the last token,\n        // then delete the last token\n        uint256 index = _records[token].index;\n        uint256 last = _tokens.length - 1;\n        _tokens[index] = _tokens[last];\n        _records[_tokens[index]].index = index;\n        _tokens.pop();\n        _records[token] = Record({\n            bound: false,\n            index: 0,\n            denorm: 0,\n            balance: 0\n        });\n\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\n        _pushUnderlying(token, _factory, tokenExitFee);\n    }\n\n    // Absorb any tokens that have been sent to this contract into the pool\n    function gulp(address token) external _logs_ _lock_ {\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\n        _records[token].balance = BIERC20(token).balanceOf(address(this));\n    }\n\n    function getSpotPrice(address tokenIn, address tokenOut)\n        external\n        view\n        _viewlock_\n        returns (uint256 spotPrice)\n    {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return\n            calcSpotPrice(\n                inRecord.balance,\n                inRecord.denorm,\n                outRecord.balance,\n                outRecord.denorm,\n                _swapFee\n            );\n    }\n\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n        external\n        view\n        _viewlock_\n        returns (uint256 spotPrice)\n    {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return\n            calcSpotPrice(\n                inRecord.balance,\n                inRecord.denorm,\n                outRecord.balance,\n                outRecord.denorm,\n                0\n            );\n    }\n\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\n        external\n        _logs_\n        _lock_\n    {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 ratio = bdiv(poolAmountOut, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n            uint256 tokenAmountIn = bmul(ratio, bal);\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\n        }\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n    }\n\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\n        external\n        _logs_\n        _lock_\n    {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n\n        uint256 poolTotal = totalSupply();\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _pushPoolShare(_factory, exitFee);\n        _burnPoolShare(pAiAfterExitFee);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint256 bal = _records[t].balance;\n            uint256 tokenAmountOut = bmul(ratio, bal);\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\n        }\n    }\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    )\n        external\n        _logs_\n        _lock_\n        returns (uint256 tokenAmountOut, uint256 spotPriceAfter)\n    {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(\n            tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO),\n            \"ERR_MAX_IN_RATIO\"\n        );\n\n        uint256 spotPriceBefore =\n            calcSpotPrice(\n                inRecord.balance,\n                inRecord.denorm,\n                outRecord.balance,\n                outRecord.denorm,\n                _swapFee\n            );\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        tokenAmountOut = calcOutGivenIn(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            tokenAmountIn,\n            _swapFee\n        );\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            _swapFee\n        );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(\n            spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut),\n            \"ERR_MATH_APPROX\"\n        );\n\n        emit LOG_SWAP(\n            msg.sender,\n            tokenIn,\n            tokenOut,\n            tokenAmountIn,\n            tokenAmountOut\n        );\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return (tokenAmountOut, spotPriceAfter);\n    }\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint256 maxAmountIn,\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPrice\n    )\n        external\n        _logs_\n        _lock_\n        returns (uint256 tokenAmountIn, uint256 spotPriceAfter)\n    {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(\n            tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO),\n            \"ERR_MAX_OUT_RATIO\"\n        );\n\n        uint256 spotPriceBefore =\n            calcSpotPrice(\n                inRecord.balance,\n                inRecord.denorm,\n                outRecord.balance,\n                outRecord.denorm,\n                _swapFee\n            );\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        tokenAmountIn = calcInGivenOut(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            tokenAmountOut,\n            _swapFee\n        );\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        spotPriceAfter = calcSpotPrice(\n            inRecord.balance,\n            inRecord.denorm,\n            outRecord.balance,\n            outRecord.denorm,\n            _swapFee\n        );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(\n            spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut),\n            \"ERR_MATH_APPROX\"\n        );\n\n        emit LOG_SWAP(\n            msg.sender,\n            tokenIn,\n            tokenOut,\n            tokenAmountIn,\n            tokenAmountOut\n        );\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return (tokenAmountIn, spotPriceAfter);\n    }\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external _logs_ _lock_ returns (uint256 poolAmountOut) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(\n            tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO),\n            \"ERR_MAX_IN_RATIO\"\n        );\n\n        Record storage inRecord = _records[tokenIn];\n\n        poolAmountOut = calcPoolOutGivenSingleIn(\n            inRecord.balance,\n            inRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            tokenAmountIn,\n            _swapFee\n        );\n\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        return poolAmountOut;\n    }\n\n    function joinswapPoolAmountOut(\n        address tokenIn,\n        uint256 poolAmountOut,\n        uint256 maxAmountIn\n    ) external _logs_ _lock_ returns (uint256 tokenAmountIn) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        tokenAmountIn = calcSingleInGivenPoolOut(\n            inRecord.balance,\n            inRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            poolAmountOut,\n            _swapFee\n        );\n\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\n\n        require(\n            tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO),\n            \"ERR_MAX_IN_RATIO\"\n        );\n\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n\n        return tokenAmountIn;\n    }\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint256 poolAmountIn,\n        uint256 minAmountOut\n    ) external _logs_ _lock_ returns (uint256 tokenAmountOut) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n\n        Record storage outRecord = _records[tokenOut];\n\n        tokenAmountOut = calcSingleOutGivenPoolIn(\n            outRecord.balance,\n            outRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            poolAmountIn,\n            _swapFee\n        );\n\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        require(\n            tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO),\n            \"ERR_MAX_OUT_RATIO\"\n        );\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\n        _pushPoolShare(_factory, exitFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return tokenAmountOut;\n    }\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external _logs_ _lock_ returns (uint256 poolAmountIn) {\n        require(_finalized, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        require(\n            tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO),\n            \"ERR_MAX_OUT_RATIO\"\n        );\n\n        Record storage outRecord = _records[tokenOut];\n\n        poolAmountIn = calcPoolInGivenSingleOut(\n            outRecord.balance,\n            outRecord.denorm,\n            _totalSupply,\n            _totalWeight,\n            tokenAmountOut,\n            _swapFee\n        );\n\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\n\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\n\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\n        _pushPoolShare(_factory, exitFee);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n\n        return poolAmountIn;\n    }\n\n    // ==\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\n    // You must `_lock_` or otherwise ensure reentry-safety\n\n    function _pullUnderlying(\n        address erc20,\n        address from,\n        uint256 amount\n    ) internal {\n        bool xfer = BIERC20(erc20).transferFrom(from, address(this), amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pushUnderlying(\n        address erc20,\n        address to,\n        uint256 amount\n    ) internal {\n        bool xfer = BIERC20(erc20).transfer(to, amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pullPoolShare(address from, uint256 amount) internal {\n        _pull(from, amount);\n    }\n\n    function _pushPoolShare(address to, uint256 amount) internal {\n        _push(to, amount);\n    }\n\n    function _mintPoolShare(uint256 amount) internal {\n        _mint(amount);\n    }\n\n    function _burnPoolShare(uint256 amount) internal {\n        _burn(amount);\n    }\n}\n"
    },
    "contracts/balancer/BToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./BNum.sol\";\n\n// Highly opinionated token implementation\n\ninterface BIERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address whom) external view returns (uint256);\n\n    function allowance(address src, address dst)\n        external\n        view\n        returns (uint256);\n\n    function approve(address dst, uint256 amt) external returns (bool);\n\n    function transfer(address dst, uint256 amt) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external returns (bool);\n}\n\ncontract BTokenBase is BNum {\n    mapping(address => uint256) internal _balance;\n    mapping(address => mapping(address => uint256)) internal _allowance;\n    uint256 internal _totalSupply;\n\n    event Approval(address indexed src, address indexed dst, uint256 amt);\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\n\n    function _mint(uint256 amt) internal {\n        _balance[address(this)] = badd(_balance[address(this)], amt);\n        _totalSupply = badd(_totalSupply, amt);\n        emit Transfer(address(0), address(this), amt);\n    }\n\n    function _burn(uint256 amt) internal {\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\n        _totalSupply = bsub(_totalSupply, amt);\n        emit Transfer(address(this), address(0), amt);\n    }\n\n    function _move(\n        address src,\n        address dst,\n        uint256 amt\n    ) internal {\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[src] = bsub(_balance[src], amt);\n        _balance[dst] = badd(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint256 amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint256 amt) internal {\n        _move(from, address(this), amt);\n    }\n}\n\ncontract BToken is BTokenBase, BIERC20 {\n    string private _name = \"Balancer Pool Token\";\n    string private _symbol = \"BPT\";\n    uint8 private _decimals = 18;\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function allowance(address src, address dst)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) external view override returns (uint256) {\n        return _balance[whom];\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint256 amt)\n        external\n        override\n        returns (bool)\n    {\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function increaseApproval(address dst, uint256 amt)\n        external\n        returns (bool)\n    {\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function decreaseApproval(address dst, uint256 amt)\n        external\n        returns (bool)\n    {\n        uint256 oldValue = _allowance[msg.sender][dst];\n        if (amt > oldValue) {\n            _allowance[msg.sender][dst] = 0;\n        } else {\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\n        }\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function transfer(address dst, uint256 amt)\n        external\n        override\n        returns (bool)\n    {\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external override returns (bool) {\n        require(\n            msg.sender == src || amt <= _allowance[src][msg.sender],\n            \"ERR_BTOKEN_BAD_CALLER\"\n        );\n        _move(src, dst, amt);\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n            _allowance[src][msg.sender] = bsub(\n                _allowance[src][msg.sender],\n                amt\n            );\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/balancer/BMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./BNum.sol\";\n\ncontract BMath is BBronze, BConst, BNum {\n    /**********************************************************************************************\n    // calcSpotPrice                                                                             //\n    // sP = spotPrice                                                                            //\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcSpotPrice(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 swapFee\n    ) public pure returns (uint256 spotPrice) {\n        uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\n        uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\n        uint256 ratio = bdiv(numer, denom);\n        uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\n        return (spotPrice = bmul(ratio, scale));\n    }\n\n    /**********************************************************************************************\n    // calcOutGivenIn                                                                            //\n    // aO = tokenAmountOut                                                                       //\n    // bO = tokenBalanceOut                                                                      //\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n    // wO = tokenWeightOut                                                                       //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcOutGivenIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountOut) {\n        uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n        uint256 adjustedIn = bsub(BONE, swapFee);\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n        uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n        uint256 foo = bpow(y, weightRatio);\n        uint256 bar = bsub(BONE, foo);\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcInGivenOut                                                                            //\n    // aI = tokenAmountIn                                                                        //\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n    // wI = tokenWeightIn           --------------------------------------------                 //\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n    // sF = swapFee                                                                              //\n    **********************************************************************************************/\n    function calcInGivenOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountIn) {\n        uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n        uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\n        uint256 y = bdiv(tokenBalanceOut, diff);\n        uint256 foo = bpow(y, weightRatio);\n        foo = bsub(foo, BONE);\n        tokenAmountIn = bsub(BONE, swapFee);\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcPoolOutGivenSingleIn                                                                  //\n    // pAo = poolAmountOut         /                                              \\              //\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n    // pS = poolSupply            \\\\                    tBi               /        /             //\n    // sF = swapFee                \\                                              /              //\n    **********************************************************************************************/\n    function calcPoolOutGivenSingleIn(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 poolAmountOut) {\n        // Charge the trading fee for the proportion of tokenAi\n        // which is implicitly traded to the other pool tokens.\n        // That proportion is (1- weightTokenIn)\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\n\n        uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n        uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n        uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n        return poolAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcSingleInGivenPoolOut                                                                  //\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n    // bI = balanceIn          tAi =  --------------------------------------------               //\n    // wI = weightIn                              /      wI  \\                                   //\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n    // sF = swapFee                               \\      tW  /                                   //\n    **********************************************************************************************/\n    function calcSingleInGivenPoolOut(\n        uint256 tokenBalanceIn,\n        uint256 tokenWeightIn,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountIn) {\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n        uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n        uint256 boo = bdiv(BONE, normalizedWeight);\n        uint256 tokenInRatio = bpow(poolRatio, boo);\n        uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n        uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n        uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n        return tokenAmountIn;\n    }\n\n    /**********************************************************************************************\n    // calcSingleOutGivenPoolIn                                                                  //\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n    // tW = totalWeight                    /     /      wO \\       \\                             //\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n    // eF = exitFee                        \\     \\      tW /       /                             //\n    **********************************************************************************************/\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) public pure returns (uint256 tokenAmountOut) {\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        // charge exit fee on the pool token side\n        // pAiAfterExitFee = pAi*(1-exitFee)\n        uint256 poolAmountInAfterExitFee =\n            bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\n        uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\n        uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\n        uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n        uint256 tokenAmountOutBeforeSwapFee =\n            bsub(tokenBalanceOut, newTokenBalanceOut);\n\n        // charge swap fee on the output token side\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\n        return tokenAmountOut;\n    }\n\n    /**********************************************************************************************\n    // calcPoolInGivenSingleOut                                                                  //\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n    // tW = totalWeight           -------------------------------------------------------------  //\n    // sF = swapFee                                        ( 1 - eF )                            //\n    // eF = exitFee                                                                              //\n    **********************************************************************************************/\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) public pure returns (uint256 poolAmountIn) {\n        // charge swap fee on the output token side\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n        uint256 zoo = bsub(BONE, normalizedWeight);\n        uint256 zar = bmul(zoo, swapFee);\n        uint256 tokenAmountOutBeforeSwapFee =\n            bdiv(tokenAmountOut, bsub(BONE, zar));\n\n        uint256 newTokenBalanceOut =\n            bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n        uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n        uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\n        uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n\n        // charge exit fee on the pool token side\n        // pAi = pAiAfterExitFee/(1-exitFee)\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\n        return poolAmountIn;\n    }\n}\n"
    },
    "contracts/balancer/BNum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n    function btoi(uint256 a) internal pure returns (uint256) {\n        return a / BONE;\n    }\n\n    function bfloor(uint256 a) internal pure returns (uint256) {\n        return btoi(a) * BONE;\n    }\n\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (uint256 c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256, bool)\n    {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint256 c1 = c0 + (BONE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint256 c2 = c1 / BONE;\n        return c2;\n    }\n\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint256 c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint256 c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint256 c2 = c1 / b;\n        return c2;\n    }\n\n    // DSMath.wpow\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n        uint256 z = n % 2 != 0 ? a : BONE;\n\n        for (n /= 2; n != 0; n /= 2) {\n            a = bmul(a, a);\n\n            if (n % 2 != 0) {\n                z = bmul(z, a);\n            }\n        }\n        return z;\n    }\n\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n    // of approximation of b^0.w\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n        uint256 whole = bfloor(exp);\n        uint256 remain = bsub(exp, whole);\n\n        uint256 wholePow = bpowi(base, btoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n        return bmul(wholePow, partialResult);\n    }\n\n    function bpowApprox(\n        uint256 base,\n        uint256 exp,\n        uint256 precision\n    ) internal pure returns (uint256) {\n        // term 0:\n        uint256 a = exp;\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\n        uint256 term = BONE;\n        uint256 sum = term;\n        bool negative = false;\n\n        // term(k) = numer / denom\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\n        // continue until term is less than precision\n        for (uint256 i = 1; term >= precision; i++) {\n            uint256 bigK = i * BONE;\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n            term = bmul(term, bmul(c, x));\n            term = bdiv(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = bsub(sum, term);\n            } else {\n                sum = badd(sum, term);\n            }\n        }\n\n        return sum;\n    }\n}\n"
    },
    "contracts/balancer/BConst.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nimport \"./BColor.sol\";\n\ncontract BConst is BBronze {\n    uint256 public constant BONE = 10**18;\n\n    uint256 public constant MIN_BOUND_TOKENS = 2;\n    uint256 public constant MAX_BOUND_TOKENS = 8;\n\n    uint256 public constant MIN_FEE = BONE / 10**6;\n    uint256 public constant MAX_FEE = BONE / 10;\n    uint256 public constant EXIT_FEE = 0;\n\n    uint256 public constant MIN_WEIGHT = BONE;\n    uint256 public constant MAX_WEIGHT = BONE * 50;\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n    uint256 public constant MIN_BALANCE = BONE / 10**12;\n\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\n\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/balancer/BColor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\nabstract contract BColor {\n    function getColor() external view virtual returns (bytes32);\n}\n\ncontract BBronze is BColor {\n    function getColor() external pure override returns (bytes32) {\n        return bytes32(\"BRONZE\");\n    }\n}\n"
    },
    "contracts/SimpleERC20.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./Ownable.sol\";\n\ncontract SimpleERC20 is ERC20, Ownable {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ERC20(name, symbol) {\n        _setupDecimals(decimals);\n    }\n\n    function mint(address account, uint256 amount) external onlyOwner {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) external onlyOwner {\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/TokenFaucet.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\n// Test Token\n\nimport \"./Ownable.sol\";\n\ncontract TokenFaucet is Ownable {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    address private _owner;\n\n    uint256 internal _totalSupply;\n\n    mapping(address => uint256) private _balance;\n    mapping(address => mapping(address => uint256)) private _allowance;\n    mapping(address => uint256) private lastAccessTime;\n\n    uint256 private constant waitTime = 30 minutes;\n    uint256 public mintAmt;\n\n    event Approval(address indexed src, address indexed dst, uint256 amt);\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\n\n    // Math\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= a);\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a);\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _mintAmt\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        mintAmt = _mintAmt;\n    }\n\n    function setMintAmount(uint256 _mintAmount) external onlyOwner {\n        mintAmt = _mintAmount;\n    }\n\n    function _move(\n        address src,\n        address dst,\n        uint256 amt\n    ) internal {\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BALANCE\");\n        _balance[src] = sub(_balance[src], amt);\n        _balance[dst] = add(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint256 amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint256 amt) internal {\n        _move(from, address(this), amt);\n    }\n\n    function _mint(address dst, uint256 amt) internal {\n        _balance[dst] = add(_balance[dst], amt);\n        _totalSupply = add(_totalSupply, amt);\n        emit Transfer(address(0), dst, amt);\n    }\n\n    function allowance(address src, address dst) external view returns (uint256) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) external view returns (uint256) {\n        return _balance[whom];\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint256 amt) external returns (bool) {\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function mintAsOwner(address dst, uint256 amt) public onlyOwner returns (bool) {\n        _mint(dst, amt);\n        return true;\n    }\n\n    function allowedToMint(address whom) internal view returns (bool) {\n        if (lastAccessTime[whom] == 0) {\n            return true;\n        } else if (block.timestamp >= lastAccessTime[whom] + waitTime) {\n            return true;\n        }\n        return false;\n    }\n\n    function mint() public returns (bool) {\n        require(allowedToMint(msg.sender));\n        lastAccessTime[msg.sender] = block.timestamp;\n        _mint(msg.sender, mintAmt * 10**decimals);\n        return true;\n    }\n\n    function burn(uint256 amt) public returns (bool) {\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\n        _balance[address(this)] = sub(_balance[address(this)], amt);\n        _totalSupply = sub(_totalSupply, amt);\n        emit Transfer(address(this), address(0), amt);\n        return true;\n    }\n\n    function transfer(address dst, uint256 amt) external returns (bool) {\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amt\n    ) external returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\n        _move(src, dst, amt);\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n            _allowance[src][msg.sender] = sub(_allowance[src][msg.sender], amt);\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/GyroLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"./BalancerGyroRouter.sol\";\nimport \"./GyroFund.sol\";\nimport \"./Ownable.sol\";\n\ncontract GyroLib is Ownable {\n    GyroFundV1 fund;\n    BalancerExternalTokenRouter externalTokensRouter;\n\n    constructor(address gyroFundAddress, address externalTokensRouterAddress) {\n        fund = GyroFundV1(gyroFundAddress);\n        externalTokensRouter = BalancerExternalTokenRouter(externalTokensRouterAddress);\n    }\n\n    function setFundAddress(address _fundAddress) external onlyOwner {\n        fund = GyroFundV1(_fundAddress);\n    }\n\n    function setRouterAddress(address _routerAddress) external onlyOwner {\n        externalTokensRouter = BalancerExternalTokenRouter(_routerAddress);\n    }\n\n    function mintFromUnderlyingTokens(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _minAmountOut\n    ) public returns (uint256) {\n        for (uint256 i = 0; i < _tokensIn.length; i++) {\n            bool success =\n                IERC20(_tokensIn[i]).transferFrom(msg.sender, address(this), _amountsIn[i]);\n            require(success, \"failed to transfer tokens from GyroFund to GryoRouter\");\n            IERC20(_tokensIn[i]).approve(address(externalTokensRouter), _amountsIn[i]);\n        }\n        (address[] memory bptTokens, uint256[] memory amounts) =\n            externalTokensRouter.deposit(_tokensIn, _amountsIn);\n\n        (address[] memory sortedAddresses, uint256[] memory sortedAmounts) =\n            sortBPTokenstoPools(bptTokens, amounts);\n\n        for (uint256 i = 0; i < sortedAddresses.length; i++) {\n            IERC20(sortedAddresses[i]).approve(address(fund), sortedAmounts[i]);\n        }\n        uint256 minted = fund.mint(sortedAddresses, sortedAmounts, _minAmountOut);\n        require(fund.transfer(msg.sender, minted), \"failed to send back gyro\");\n        return minted;\n    }\n\n    function redeemToUnderlyingTokens(\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut,\n        uint256 _maxRedeemed\n    ) public returns (uint256) {\n        (address[] memory _BPTokensIn, uint256[] memory _BPAmountsIn) =\n            externalTokensRouter.estimateWithdraw(_tokensOut, _amountsOut);\n\n        (address[] memory _sortedAddresses, uint256[] memory _sortedAmounts) =\n            sortBPTokenstoPools(_BPTokensIn, _BPAmountsIn);\n\n        (uint256 errorCode, uint256 _amountToRedeem) =\n            fund.redeemChecksPass(_sortedAddresses, _sortedAmounts, _maxRedeemed);\n\n        require(errorCode == 0, fund.errorCodeToString(errorCode));\n        require(_amountToRedeem <= _maxRedeemed, \"too much slippage\");\n\n        require(\n            fund.transferFrom(msg.sender, address(this), _amountToRedeem),\n            \"failed to send gyro to lib\"\n        );\n\n        uint256 _amountRedeemed = fund.redeem(_sortedAddresses, _sortedAmounts, _maxRedeemed);\n\n        for (uint256 i = 0; i < _sortedAddresses.length; i++) {\n            require(\n                IERC20(_sortedAddresses[i]).approve(\n                    address(externalTokensRouter),\n                    _sortedAmounts[i]\n                ),\n                \"failed to approve BPTokens\"\n            );\n        }\n\n        externalTokensRouter.withdraw(_tokensOut, _amountsOut);\n\n        for (uint256 i = 0; i < _tokensOut.length; i++) {\n            IERC20(_tokensOut[i]).transfer(msg.sender, _amountsOut[i]);\n        }\n\n        return _amountRedeemed;\n    }\n\n    function estimateMintedGyro(address[] memory _tokensIn, uint256[] memory _amountsIn)\n        public\n        view\n        returns (uint256)\n    {\n        (address[] memory bptTokens, uint256[] memory amounts) =\n            externalTokensRouter.estimateDeposit(_tokensIn, _amountsIn);\n\n        (address[] memory _sortedAddresses, uint256[] memory _sortedAmounts) =\n            sortBPTokenstoPools(bptTokens, amounts);\n\n        (, uint256 _amountToMint) = fund.mintChecksPass(_sortedAddresses, _sortedAmounts, 10);\n\n        return _amountToMint;\n    }\n\n    function wouldMintChecksPass(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _minGyroMinted\n    ) public view returns (uint256) {\n        (address[] memory bptTokens, uint256[] memory amounts) =\n            externalTokensRouter.estimateDeposit(_tokensIn, _amountsIn);\n\n        (address[] memory sortedAddresses, uint256[] memory sortedAmounts) =\n            sortBPTokenstoPools(bptTokens, amounts);\n\n        (uint256 errorCode, ) = fund.mintChecksPass(sortedAddresses, sortedAmounts, _minGyroMinted);\n\n        return errorCode;\n    }\n\n    function wouldRedeemChecksPass(\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut,\n        uint256 _maxGyroRedeemed\n    ) public view returns (uint256) {\n        (address[] memory bptTokens, uint256[] memory amounts) =\n            externalTokensRouter.estimateDeposit(_tokensOut, _amountsOut);\n\n        (address[] memory sortedAddresses, uint256[] memory sortedAmounts) =\n            sortBPTokenstoPools(bptTokens, amounts);\n\n        (uint256 errorCode, ) =\n            fund.redeemChecksPass(sortedAddresses, sortedAmounts, _maxGyroRedeemed);\n\n        return errorCode;\n    }\n\n    function estimateRedeemedGyro(address[] memory _tokensOut, uint256[] memory _amountsOut)\n        public\n        view\n        returns (uint256)\n    {\n        (address[] memory bptTokens, uint256[] memory amounts) =\n            externalTokensRouter.estimateWithdraw(_tokensOut, _amountsOut);\n\n        (address[] memory _sortedAddresses, uint256[] memory _sortedAmounts) =\n            sortBPTokenstoPools(bptTokens, amounts);\n\n        (, uint256 _amountToRedeem) = fund.redeemChecksPass(_sortedAddresses, _sortedAmounts, 10);\n\n        return _amountToRedeem;\n    }\n\n    function getSupportedTokens() external view returns (address[] memory) {\n        return fund.getUnderlyingTokenAddresses();\n    }\n\n    function getSupportedPools() external view returns (address[] memory) {\n        return fund.poolAddresses();\n    }\n\n    function getReserveValues()\n        external\n        view\n        returns (\n            uint256,\n            address[] memory,\n            uint256[] memory\n        )\n    {\n        return fund.getReserveValues();\n    }\n\n    function sortBPTokenstoPools(address[] memory _BPTokensIn, uint256[] memory amounts)\n        public\n        view\n        returns (address[] memory, uint256[] memory)\n    {\n        address[] memory sortedAddresses = fund.poolAddresses();\n        uint256[] memory sortedAmounts = new uint256[](sortedAddresses.length);\n\n        for (uint256 i = 0; i < _BPTokensIn.length; i++) {\n            bool found = false;\n            for (uint256 j = 0; j < sortedAddresses.length; j++) {\n                if (sortedAddresses[j] == _BPTokensIn[i]) {\n                    sortedAmounts[j] += amounts[i];\n                    found = true;\n                    break;\n                }\n            }\n            require(found, \"could not find valid pool\");\n        }\n\n        return (sortedAddresses, sortedAmounts);\n    }\n}\n"
    },
    "contracts/BalancerGyroRouter.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./GyroRouter.sol\";\nimport \"./balancer/BPool.sol\";\nimport \"./Ownable.sol\";\n\ncontract BalancerExternalTokenRouter is GyroRouter, Ownable {\n    mapping(address => address[]) public pools;\n    address[] public tokens;\n\n    event UnderlyingTokensDeposited(address[] indexed bpAddresses, uint256[] indexed bpAmounts);\n\n    function deposit(address[] memory _tokensIn, uint256[] memory _amountsIn)\n        external\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        address[] memory _bpAddresses = new address[](_tokensIn.length);\n        uint256[] memory _bpAmounts = new uint256[](_amountsIn.length);\n\n        for (uint256 i = 0; i < _tokensIn.length; i++) {\n            address token = _tokensIn[i];\n            uint256 amount = _amountsIn[i];\n            bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);\n            require(success, \"failed to transfer tokens from sender to GryoRouter\");\n\n            BPool pool = BPool(choosePoolToDeposit(token, amount));\n            uint256 poolAmountOut = pool.joinswapExternAmountIn(token, amount, 0);\n            success = pool.transfer(msg.sender, poolAmountOut);\n            require(success, \"failed to transfer BPT to sender\");\n\n            _bpAmounts[i] = poolAmountOut;\n            _bpAddresses[i] = address(pool);\n        }\n\n        emit UnderlyingTokensDeposited(_bpAddresses, _bpAmounts);\n        return (_bpAddresses, _bpAmounts);\n    }\n\n    function estimateDeposit(address[] memory _tokensIn, uint256[] memory _amountsIn)\n        external\n        view\n        returns (address[] memory, uint256[] memory)\n    {\n        address[] memory _bpAddresses = new address[](_tokensIn.length);\n        uint256[] memory _bpAmounts = new uint256[](_amountsIn.length);\n\n        for (uint256 i = 0; i < _tokensIn.length; i++) {\n            address token = _tokensIn[i];\n            uint256 amount = _amountsIn[i];\n\n            BPool pool = BPool(choosePoolToDeposit(token, amount));\n            uint256 poolAmountOut = calcPoolOutGivenSingleIn(pool, token, amount);\n            _bpAddresses[i] = address(pool);\n            _bpAmounts[i] = poolAmountOut;\n        }\n        return (_bpAddresses, _bpAmounts);\n    }\n\n    function estimateWithdraw(address[] memory _tokensOut, uint256[] memory _amountsOut)\n        external\n        view\n        returns (address[] memory, uint256[] memory)\n    {\n        address[] memory _bpAddresses = new address[](_tokensOut.length);\n        uint256[] memory _bpAmounts = new uint256[](_amountsOut.length);\n\n        for (uint256 i = 0; i < _tokensOut.length; i++) {\n            address token = _tokensOut[i];\n            uint256 amount = _amountsOut[i];\n\n            BPool pool = BPool(choosePoolToDeposit(token, amount));\n            uint256 poolAmountIn = calcPoolInGivenSingleOut(pool, token, amount);\n            _bpAddresses[i] = address(pool);\n            _bpAmounts[i] = poolAmountIn;\n        }\n        return (_bpAddresses, _bpAmounts);\n    }\n\n    function withdraw(address[] memory _tokensOut, uint256[] memory _amountsOut)\n        external\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        for (uint256 i = 0; i < _tokensOut.length; i++) {\n            address token = _tokensOut[i];\n            uint256 amount = _amountsOut[i];\n            BPool pool = BPool(choosePoolToWithdraw(token, amount));\n            uint256 poolAmountIn = calcPoolInGivenSingleOut(pool, token, amount);\n\n            bool success = pool.transferFrom(msg.sender, address(this), poolAmountIn);\n            require(success, \"failed to transfer BPT from sender to GryoRouter\");\n\n            pool.exitswapExternAmountOut(token, amount, poolAmountIn);\n\n            success = IERC20(token).transfer(msg.sender, amount);\n            require(success, \"failed to transfer token to sender\");\n        }\n        return (_tokensOut, _amountsOut);\n    }\n\n    function calcPoolOutGivenSingleIn(\n        BPool pool,\n        address _token,\n        uint256 _amount\n    ) internal view returns (uint256) {\n        uint256 tokenBalanceIn = pool.getBalance(_token);\n        uint256 tokenWeightIn = pool.getDenormalizedWeight(_token);\n        uint256 poolSupply = pool.totalSupply();\n        uint256 totalWeight = pool.getTotalDenormalizedWeight();\n        uint256 swapFee = pool.getSwapFee();\n        return\n            pool.calcPoolOutGivenSingleIn(\n                tokenBalanceIn,\n                tokenWeightIn,\n                poolSupply,\n                totalWeight,\n                _amount,\n                swapFee\n            );\n    }\n\n    function calcPoolInGivenSingleOut(\n        BPool pool,\n        address _token,\n        uint256 _amount\n    ) internal view returns (uint256) {\n        uint256 tokenBalanceOut = pool.getBalance(_token);\n        uint256 tokenWeightOut = pool.getDenormalizedWeight(_token);\n        uint256 poolSupply = pool.totalSupply();\n        uint256 totalWeight = pool.getTotalDenormalizedWeight();\n        uint256 swapFee = pool.getSwapFee();\n        return\n            pool.calcPoolInGivenSingleOut(\n                tokenBalanceOut,\n                tokenWeightOut,\n                poolSupply,\n                totalWeight,\n                _amount,\n                swapFee\n            );\n    }\n\n    function choosePoolToDeposit(address _token, uint256 _amount) private view returns (address) {\n        address[] storage candidates = pools[_token];\n        require(candidates.length > 0, \"token not supported\");\n        // TODO: choose better\n        return candidates[_amount % candidates.length];\n    }\n\n    function choosePoolToWithdraw(address _token, uint256 _amount) private view returns (address) {\n        address[] storage candidates = pools[_token];\n        require(candidates.length > 0, \"token not supported\");\n        // TODO: choose better\n        return candidates[_amount % candidates.length];\n    }\n\n    function addPool(address _poolAddress) public onlyOwner {\n        BPool pool = BPool(_poolAddress);\n        require(pool.isFinalized(), \"can only add finalized pools\");\n        address[] memory poolTokens = pool.getFinalTokens();\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            address tokenAddress = poolTokens[i];\n            address[] storage currentPools = pools[tokenAddress];\n            if (currentPools.length == 0) {\n                tokens.push(tokenAddress);\n            }\n            bool exists = false;\n            for (uint256 j = 0; j < currentPools.length; j++) {\n                if (currentPools[j] == _poolAddress) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists) {\n                currentPools.push(_poolAddress);\n                IERC20(tokenAddress).approve(_poolAddress, uint256(-1));\n            }\n        }\n    }\n\n    function allTokens() external view returns (address[] memory) {\n        address[] memory _tokens = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _tokens[i] = tokens[i];\n        }\n        return _tokens;\n    }\n}\n\ncontract BalancerTokenRouter is GyroRouter, Ownable {\n    function deposit(address[] memory _tokensIn, uint256[] memory _amountsIn)\n        external\n        pure\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        return (_tokensIn, _amountsIn);\n    }\n\n    function withdraw(address[] memory _tokensOut, uint256[] memory _amountsOut)\n        external\n        pure\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        return (_tokensOut, _amountsOut);\n    }\n}\n"
    },
    "contracts/GyroFund.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./GyroPriceOracle.sol\";\nimport \"./GyroRouter.sol\";\nimport \"./Ownable.sol\";\nimport \"./abdk/ABDKMath64x64.sol\";\n\ninterface GyroFund is IERC20 {\n    event Mint(address minter, uint256 amount);\n    event Redeem(address redeemer, uint256 amount);\n\n    function mint(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _minGyroMinted\n    ) external returns (uint256);\n\n    function redeem(\n        address[] memory _BPTokensOut,\n        uint256[] memory _amountsOut,\n        uint256 _maxGyroRedeemed\n    ) external returns (uint256);\n\n    /**\n     * Takes in the same parameters as mint and returns whether the\n     * mint will succeed or not as well as the estimated mint amount\n     * @param _BPTokensIn addresses of the input balancer pool tokens\n     * @param _amountsIn amounts of the input balancer pool tokens\n     * @param _minGyroMinted mininum amount of gyro to mint\n     * @return errorCode of 0 is no error happens or a value described in errors.json\n     */\n    function mintChecksPass(\n        address[] memory _BPTokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _minGyroMinted\n    ) external view returns (uint256 errorCode, uint256 estimatedAmount);\n\n    function redeemChecksPass(\n        address[] memory _BPTokensOut,\n        uint256[] memory _amountsOut,\n        uint256 _maxGyroRedeemed\n    ) external view returns (uint256 errorCode, uint256 estimatedAmount);\n\n    function getReserveValues()\n        external\n        view\n        returns (\n            uint256 errorCode,\n            address[] memory BPTokenAddresses,\n            uint256[] memory BPReserveDollarValues\n        );\n}\n\ncontract GyroFundV1 is GyroFund, Ownable, ERC20 {\n    using ExtendedMath for int128;\n    using ABDKMath64x64 for uint256;\n    using ABDKMath64x64 for int128;\n    using SafeMath for uint256;\n    using ExtendedMath for uint256;\n\n    GyroPriceOracle public gyroPriceOracle;\n    GyroRouter public gyroRouter;\n    PriceOracle public priceOracle;\n\n    struct TokenProperties {\n        address oracleAddress;\n        string tokenSymbol;\n        uint16 tokenIndex;\n    }\n\n    struct PoolProperties {\n        address poolAddress;\n        uint256 initialPoolWeight;\n        uint256 initialPoolPrice;\n    }\n\n    struct PoolStatus {\n        bool _allPoolsHealthy;\n        bool _allPoolsWithinEpsilon;\n        bool[] _inputPoolHealth;\n        bool[] _poolsWithinEpsilon;\n    }\n\n    struct Weights {\n        uint256[] _idealWeights;\n        uint256[] _currentWeights;\n        uint256[] _hypotheticalWeights;\n        uint256 _nav;\n        uint256 _dollarValue;\n        uint256 _totalPortfolioValue;\n        uint256[] _zeroArray;\n        uint256 gyroAmount;\n    }\n\n    struct FlowLogger {\n        uint256 inflowHistory;\n        uint256 outflowHistory;\n        uint256 currentBlock;\n        uint256 lastSeenBlock;\n    }\n\n    PoolProperties[] public poolProperties;\n\n    mapping(address => TokenProperties) _tokenAddressToProperties;\n    mapping(address => bool) _checkPoolIsValid;\n\n    mapping(address => bool) _checkIsStablecoin;\n\n    address[] underlyingTokenAddresses;\n\n    uint256 public portfolioWeightEpsilon;\n    uint256 lastSeenBlock;\n    uint256 inflowHistory;\n    uint256 outflowHistory;\n    uint256 memoryParam;\n\n    uint256 constant WOULD_UNBALANCE_GYROSCOPE = 1;\n    uint256 constant TOO_MUCH_SLIPPAGE = 2;\n\n    constructor(\n        uint256 _portfolioWeightEpsilon,\n        address _priceOracleAddress,\n        address _routerAddress,\n        uint256 _memoryParam\n    ) ERC20(\"Gyro Dollar\", \"GYD\") Ownable() {\n        gyroPriceOracle = GyroPriceOracle(_priceOracleAddress);\n        gyroRouter = GyroRouter(_routerAddress);\n\n        lastSeenBlock = block.number;\n        inflowHistory = 0;\n        outflowHistory = 0;\n        memoryParam = _memoryParam;\n\n        portfolioWeightEpsilon = _portfolioWeightEpsilon;\n    }\n\n    function addToken(\n        address tokenAddress,\n        address oracleAddress,\n        bool isStable\n    ) external onlyOwner {\n        for (uint256 i = 0; i < underlyingTokenAddresses.length; i++) {\n            require(underlyingTokenAddresses[i] != tokenAddress, \"this token already exists\");\n        }\n\n        _checkIsStablecoin[tokenAddress] = isStable;\n        string memory tokenSymbol = ERC20(tokenAddress).symbol();\n        _tokenAddressToProperties[tokenAddress] = TokenProperties({\n            oracleAddress: oracleAddress,\n            tokenSymbol: tokenSymbol,\n            tokenIndex: uint16(underlyingTokenAddresses.length)\n        });\n        underlyingTokenAddresses.push(tokenAddress);\n    }\n\n    function addPool(address _bpoolAddress, uint256 _initialPoolWeight) external onlyOwner {\n        // check we do not already have this pool\n        for (uint256 i = 0; i < poolProperties.length; i++) {\n            require(poolProperties[i].poolAddress != _bpoolAddress, \"this pool already exists\");\n        }\n\n        BPool _bPool = BPool(_bpoolAddress);\n        _checkPoolIsValid[_bpoolAddress] = true;\n\n        // get the addresses of the underlying tokens\n        address[] memory _bPoolUnderlyingTokens = _bPool.getFinalTokens();\n\n        // fill the underlying token prices array\n        uint256[] memory _bPoolUnderlyingTokenPrices = new uint256[](_bPoolUnderlyingTokens.length);\n        for (uint256 i = 0; i < _bPoolUnderlyingTokens.length; i++) {\n            address tokenAddress = _bPoolUnderlyingTokens[i];\n            string memory tokenSymbol = ERC20(tokenAddress).symbol();\n            _bPoolUnderlyingTokenPrices[i] = getPrice(tokenAddress, tokenSymbol);\n        }\n\n        // Calculate BPT price for the pool\n        uint256 initialPoolPrice =\n            gyroPriceOracle.getBPTPrice(_bpoolAddress, _bPoolUnderlyingTokenPrices);\n\n        poolProperties.push(\n            PoolProperties({\n                poolAddress: _bpoolAddress,\n                initialPoolWeight: _initialPoolWeight,\n                initialPoolPrice: initialPoolPrice\n            })\n        );\n    }\n\n    function calculateImpliedPoolWeights(uint256[] memory _BPTPrices)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        // order of _BPTPrices must be same as order of poolProperties\n        uint256[] memory _newWeights = new uint256[](_BPTPrices.length);\n        uint256[] memory _weightedReturns = new uint256[](_BPTPrices.length);\n\n        uint256[] memory _initPoolPrices = new uint256[](_BPTPrices.length);\n        uint256[] memory _initWeights = new uint256[](_BPTPrices.length);\n\n        for (uint256 i = 0; i < poolProperties.length; i++) {\n            _initPoolPrices[i] = poolProperties[i].initialPoolPrice;\n            _initWeights[i] = poolProperties[i].initialPoolWeight;\n        }\n\n        for (uint256 i = 0; i < _BPTPrices.length; i++) {\n            _weightedReturns[i] = _BPTPrices[i].scaledDiv(_initPoolPrices[i]).scaledMul(\n                _initWeights[i]\n            );\n        }\n\n        uint256 _returnsSum = 0;\n        for (uint256 i = 0; i < _BPTPrices.length; i++) {\n            _returnsSum = _returnsSum.add(_weightedReturns[i]);\n        }\n\n        for (uint256 i = 0; i < _BPTPrices.length; i++) {\n            _newWeights[i] = _weightedReturns[i].scaledDiv(_returnsSum);\n        }\n\n        return _newWeights;\n    }\n\n    function nav(uint256 _totalPortfolioValue) internal view returns (uint256 _nav) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply > 0) {\n            _nav = _totalPortfolioValue.scaledDiv(totalSupply());\n        } else {\n            _nav = 1e18;\n        }\n\n        return _nav;\n    }\n\n    function calculatePortfolioWeights(uint256[] memory _BPTAmounts, uint256[] memory _BPTPrices)\n        internal\n        pure\n        returns (uint256[] memory, uint256)\n    {\n        uint256[] memory _weights = new uint256[](_BPTPrices.length);\n        uint256 _totalPortfolioValue = 0;\n\n        for (uint256 i = 0; i < _BPTAmounts.length; i++) {\n            _totalPortfolioValue = _totalPortfolioValue.add(\n                _BPTAmounts[i].scaledMul(_BPTPrices[i])\n            );\n        }\n\n        if (_totalPortfolioValue == 0) {\n            return (_weights, _totalPortfolioValue);\n        }\n\n        for (uint256 i = 0; i < _BPTAmounts.length; i++) {\n            _weights[i] = _BPTAmounts[i].scaledMul(_BPTPrices[i]).scaledDiv(_totalPortfolioValue);\n        }\n\n        return (_weights, _totalPortfolioValue);\n    }\n\n    function checkStablecoinHealth(uint256 stablecoinPrice, address stablecoinAddress)\n        internal\n        view\n        returns (bool)\n    {\n        // TODO: revisit\n        //Price\n        bool _stablecoinHealthy = true;\n\n        uint256 decimals = ERC20(stablecoinAddress).decimals();\n\n        uint256 maxDeviation = 5 * 10**(decimals - 2);\n        uint256 idealPrice = 10**decimals;\n\n        if (stablecoinPrice >= idealPrice + maxDeviation) {\n            _stablecoinHealthy = false;\n        } else if (stablecoinPrice <= idealPrice - maxDeviation) {\n            _stablecoinHealthy = false;\n        }\n        console.log(stablecoinAddress, \"health\", _stablecoinHealthy);\n\n        //Volume (to do)\n\n        return _stablecoinHealthy;\n    }\n\n    function absValueSub(uint256 _number1, uint256 _number2) internal pure returns (uint256) {\n        if (_number1 >= _number2) {\n            return _number1.sub(_number2);\n        } else {\n            return _number2.sub(_number1);\n        }\n    }\n\n    function getPrice(address _token, string memory _tokenSymbol) internal view returns (uint256) {\n        return PriceOracle(_tokenAddressToProperties[_token].oracleAddress).getPrice(_tokenSymbol);\n    }\n\n    function bytes32ToString(bytes32 x) private pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n        uint256 charCount = 0;\n        for (uint256 j = 0; j < 32; j++) {\n            bytes1 char = bytes1(bytes32(uint256(x) * 2**(8 * j)));\n            if (char != 0) {\n                bytesString[charCount] = char;\n                charCount++;\n            }\n        }\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 j = 0; j < charCount; j++) {\n            bytesStringTrimmed[j] = bytesString[j];\n        }\n        return string(bytesStringTrimmed);\n    }\n\n    function getAllTokenPrices() public view returns (uint256[] memory) {\n        uint256[] memory _allUnderlyingPrices = new uint256[](underlyingTokenAddresses.length);\n        for (uint256 i = 0; i < underlyingTokenAddresses.length; i++) {\n            address _tokenAddress = underlyingTokenAddresses[i];\n            string memory _tokenSymbol =\n                _tokenAddressToProperties[underlyingTokenAddresses[i]].tokenSymbol;\n            uint256 _tokenPrice = getPrice(_tokenAddress, _tokenSymbol);\n            _allUnderlyingPrices[i] = _tokenPrice;\n        }\n        return _allUnderlyingPrices;\n    }\n\n    function mintTest(address[] memory _BPTokensIn, uint256[] memory _amountsIn)\n        public\n        onlyOwner\n        returns (uint256)\n    {\n        for (uint256 i = 0; i < _BPTokensIn.length; i++) {\n            bool success =\n                IERC20(_BPTokensIn[i]).transferFrom(msg.sender, address(this), _amountsIn[i]);\n            require(success, \"failed to transfer tokens, check allowance\");\n        }\n        uint256[] memory _allUnderlyingPrices = getAllTokenPrices();\n        uint256[] memory _currentBPTPrices = calculateAllPoolPrices(_allUnderlyingPrices);\n        uint256 _dollarValue = 0;\n\n        for (uint256 i = 0; i < _BPTokensIn.length; i++) {\n            _dollarValue = _dollarValue.add(_amountsIn[i].scaledMul(_currentBPTPrices[i]));\n        }\n\n        uint256 _gyroToMint = gyroPriceOracle.getAmountToMint(_dollarValue, 0, 1e18);\n\n        _mint(msg.sender, _gyroToMint);\n        return _gyroToMint;\n    }\n\n    function calculateAllPoolPrices(uint256[] memory _allUnderlyingPrices)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory _currentBPTPrices = new uint256[](poolProperties.length);\n\n        // Calculate BPT prices for all pools\n        for (uint256 i = 0; i < poolProperties.length; i++) {\n            BPool _bPool = BPool(poolProperties[i].poolAddress);\n\n            address[] memory _bPoolUnderlyingTokens = _bPool.getFinalTokens();\n\n            //For each pool fill the underlying token prices array\n            uint256[] memory _bPoolUnderlyingTokenPrices =\n                new uint256[](underlyingTokenAddresses.length);\n            for (uint256 j = 0; j < _bPoolUnderlyingTokens.length; j++) {\n                _bPoolUnderlyingTokenPrices[j] = _allUnderlyingPrices[\n                    _tokenAddressToProperties[_bPoolUnderlyingTokens[j]].tokenIndex\n                ];\n            }\n\n            // Calculate BPT price for the pool\n            _currentBPTPrices[i] = gyroPriceOracle.getBPTPrice(\n                poolProperties[i].poolAddress,\n                _bPoolUnderlyingTokenPrices\n            );\n        }\n\n        return _currentBPTPrices;\n    }\n\n    function poolHealthHelper(uint256[] memory _allUnderlyingPrices, uint256 _poolIndex)\n        internal\n        view\n        returns (bool)\n    {\n        bool _poolHealthy = true;\n\n        BPool _bPool = BPool(poolProperties[_poolIndex].poolAddress);\n        address[] memory _bPoolUnderlyingTokens = _bPool.getFinalTokens();\n\n        //Go through the underlying tokens within the pool\n        for (uint256 j = 0; j < _bPoolUnderlyingTokens.length; j++) {\n            if (_checkIsStablecoin[_bPoolUnderlyingTokens[j]]) {\n                uint256 _stablecoinPrice =\n                    _allUnderlyingPrices[\n                        _tokenAddressToProperties[_bPoolUnderlyingTokens[j]].tokenIndex\n                    ];\n\n                if (!checkStablecoinHealth(_stablecoinPrice, _bPoolUnderlyingTokens[j])) {\n                    _poolHealthy = false;\n                    break;\n                }\n            }\n        }\n\n        return _poolHealthy;\n    }\n\n    function checkPoolsWithinEpsilon(\n        address[] memory _BPTokensIn,\n        uint256[] memory _hypotheticalWeights,\n        uint256[] memory _idealWeights\n    ) internal view returns (bool, bool[] memory) {\n        bool _allPoolsWithinEpsilon = true;\n        bool[] memory _poolsWithinEpsilon = new bool[](_BPTokensIn.length);\n\n        for (uint256 i = 0; i < _BPTokensIn.length; i++) {\n            // Check 1: check whether hypothetical weight will be within epsilon\n            _poolsWithinEpsilon[i] = true;\n            if (_hypotheticalWeights[i] >= _idealWeights[i].add(portfolioWeightEpsilon)) {\n                _allPoolsWithinEpsilon = false;\n                _poolsWithinEpsilon[i] = false;\n            } else if (_hypotheticalWeights[i].add(portfolioWeightEpsilon) <= _idealWeights[i]) {\n                _allPoolsWithinEpsilon = false;\n                _poolsWithinEpsilon[i] = false;\n            }\n        }\n\n        return (_allPoolsWithinEpsilon, _poolsWithinEpsilon);\n    }\n\n    function checkAllPoolsHealthy(\n        address[] memory _BPTokensIn,\n        uint256[] memory _hypotheticalWeights,\n        uint256[] memory _idealWeights,\n        uint256[] memory _allUnderlyingPrices\n    )\n        internal\n        view\n        returns (\n            bool,\n            bool,\n            bool[] memory,\n            bool[] memory\n        )\n    {\n        // Check safety of input tokens\n        bool _allPoolsWithinEpsilon;\n        bool[] memory _poolsWithinEpsilon = new bool[](_BPTokensIn.length);\n        bool[] memory _inputPoolHealth = new bool[](_BPTokensIn.length);\n        bool _allPoolsHealthy = true;\n\n        (_allPoolsWithinEpsilon, _poolsWithinEpsilon) = checkPoolsWithinEpsilon(\n            _BPTokensIn,\n            _hypotheticalWeights,\n            _idealWeights\n        );\n\n        for (uint256 i = 0; i < _BPTokensIn.length; i++) {\n            _inputPoolHealth[i] = poolHealthHelper(_allUnderlyingPrices, i);\n            _allPoolsHealthy = _allPoolsHealthy && _inputPoolHealth[i];\n        }\n\n        return (_allPoolsHealthy, _allPoolsWithinEpsilon, _inputPoolHealth, _poolsWithinEpsilon);\n    }\n\n    function safeToMintOutsideEpsilon(\n        address[] memory _BPTokensIn,\n        bool[] memory _inputPoolHealth,\n        uint256[] memory _inputBPTWeights,\n        uint256[] memory _idealWeights,\n        uint256[] memory _hypotheticalWeights,\n        uint256[] memory _currentWeights,\n        bool[] memory _poolsWithinEpsilon\n    ) internal pure returns (bool _anyCheckFail) {\n        //Check that amount above epsilon is decreasing\n        //Check that unhealthy pools have input weight below ideal weight\n        //If both true, then mint\n        //note: should always be able to mint at the ideal weights!\n        _anyCheckFail = false;\n        for (uint256 i; i < _BPTokensIn.length; i++) {\n            if (!_inputPoolHealth[i]) {\n                if (_inputBPTWeights[i] > _idealWeights[i]) {\n                    _anyCheckFail = true;\n                    break;\n                }\n            }\n\n            if (!_poolsWithinEpsilon[i]) {\n                // check if _hypotheticalWeights[i] is closer to _idealWeights[i] than _currentWeights[i]\n                uint256 _distanceHypotheticalToIdeal =\n                    absValueSub(_hypotheticalWeights[i], _idealWeights[i]);\n                uint256 _distanceCurrentToIdeal = absValueSub(_currentWeights[i], _idealWeights[i]);\n\n                if (_distanceHypotheticalToIdeal >= _distanceCurrentToIdeal) {\n                    _anyCheckFail = true;\n                    break;\n                }\n            }\n        }\n\n        if (!_anyCheckFail) {\n            return true;\n        }\n    }\n\n    function checkBPTokenOrder(address[] memory _BPTokensIn) internal view returns (bool _correct) {\n        require(\n            _BPTokensIn.length == poolProperties.length,\n            \"bptokens do not have the correct number of addreses\"\n        );\n        _correct = true;\n\n        for (uint256 i = 0; i < poolProperties.length; i++) {\n            if (poolProperties[i].poolAddress != _BPTokensIn[i]) {\n                _correct = false;\n                break;\n            }\n        }\n\n        return _correct;\n    }\n\n    function checkUnhealthyMovesToIdeal(\n        address[] memory _BPTokensIn,\n        bool[] memory _inputPoolHealth,\n        uint256[] memory _inputBPTWeights,\n        uint256[] memory _idealWeights\n    ) internal pure returns (bool _launch) {\n        bool _unhealthyMovesTowardIdeal = true;\n        for (uint256 i; i < _BPTokensIn.length; i++) {\n            if (!_inputPoolHealth[i]) {\n                if (_inputBPTWeights[i] > _idealWeights[i]) {\n                    _unhealthyMovesTowardIdeal = false;\n                    break;\n                }\n            }\n        }\n\n        if (_unhealthyMovesTowardIdeal) {\n            _launch = true;\n        }\n    }\n\n    function safeToMint(\n        address[] memory _BPTokensIn,\n        uint256[] memory _hypotheticalWeights,\n        uint256[] memory _idealWeights,\n        uint256[] memory _allUnderlyingPrices,\n        uint256[] memory _amountsIn,\n        uint256[] memory _currentBPTPrices,\n        uint256[] memory _currentWeights\n    ) internal view returns (bool _launch) {\n        _launch = false;\n\n        PoolStatus memory poolStatus;\n\n        (\n            poolStatus._allPoolsHealthy,\n            poolStatus._allPoolsWithinEpsilon,\n            poolStatus._inputPoolHealth,\n            poolStatus._poolsWithinEpsilon\n        ) = checkAllPoolsHealthy(\n            _BPTokensIn,\n            _hypotheticalWeights,\n            _idealWeights,\n            _allUnderlyingPrices\n        );\n\n        // if check 1 succeeds and all pools healthy, then proceed with minting\n        console.log(\n            \"_allPoolsHealthy\",\n            poolStatus._allPoolsHealthy,\n            \"_allPoolsWithinEpsilon\",\n            poolStatus._allPoolsWithinEpsilon\n        );\n        if (poolStatus._allPoolsHealthy) {\n            if (poolStatus._allPoolsWithinEpsilon) {\n                _launch = true;\n            }\n        } else {\n            // calculate proportional values of assets user wants to pay with\n            (uint256[] memory _inputBPTWeights, uint256 _totalPortfolioValue) =\n                calculatePortfolioWeights(_amountsIn, _currentBPTPrices);\n            if (_totalPortfolioValue == 0) {\n                _inputBPTWeights = _idealWeights;\n            }\n\n            //Check that unhealthy pools have input weight below ideal weight. If true, mint\n            if (poolStatus._allPoolsWithinEpsilon) {\n                _launch = checkUnhealthyMovesToIdeal(\n                    _BPTokensIn,\n                    poolStatus._inputPoolHealth,\n                    _inputBPTWeights,\n                    _idealWeights\n                );\n            }\n            //Outside of the epsilon boundary\n            else {\n                _launch = safeToMintOutsideEpsilon(\n                    _BPTokensIn,\n                    poolStatus._inputPoolHealth,\n                    _inputBPTWeights,\n                    _idealWeights,\n                    _hypotheticalWeights,\n                    _currentWeights,\n                    poolStatus._poolsWithinEpsilon\n                );\n            }\n        }\n\n        return _launch;\n    }\n\n    function safeToRedeem(\n        address[] memory _BPTokensOut,\n        uint256[] memory _hypotheticalWeights,\n        uint256[] memory _idealWeights,\n        uint256[] memory _currentWeights\n    ) internal view returns (bool) {\n        bool _launch = false;\n        bool _allPoolsWithinEpsilon;\n        bool[] memory _poolsWithinEpsilon = new bool[](_BPTokensOut.length);\n\n        (_allPoolsWithinEpsilon, _poolsWithinEpsilon) = checkPoolsWithinEpsilon(\n            _BPTokensOut,\n            _hypotheticalWeights,\n            _idealWeights\n        );\n        if (_allPoolsWithinEpsilon) {\n            _launch = true;\n            return _launch;\n        }\n\n        // check if weights that are beyond epsilon boundary are closer to ideal than current weights\n        bool _checkFail = false;\n        for (uint256 i; i < _BPTokensOut.length; i++) {\n            if (!_poolsWithinEpsilon[i]) {\n                // check if _hypotheticalWeights[i] is closer to _idealWeights[i] than _currentWeights[i]\n                uint256 _distanceHypotheticalToIdeal =\n                    absValueSub(_hypotheticalWeights[i], _idealWeights[i]);\n                uint256 _distanceCurrentToIdeal = absValueSub(_currentWeights[i], _idealWeights[i]);\n\n                if (_distanceHypotheticalToIdeal >= _distanceCurrentToIdeal) {\n                    _checkFail = true;\n                    break;\n                }\n            }\n        }\n\n        if (!_checkFail) {\n            _launch = true;\n        }\n\n        return _launch;\n    }\n\n    function calculateAllWeights(\n        uint256[] memory _currentBPTPrices,\n        address[] memory _BPTokens,\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut\n    )\n        internal\n        view\n        returns (\n            uint256[] memory _idealWeights,\n            uint256[] memory _currentWeights,\n            uint256[] memory _hypotheticalWeights,\n            uint256 _nav,\n            uint256 _totalPortfolioValue\n        )\n    {\n        //Calculate the up to date ideal portfolio weights\n        _idealWeights = calculateImpliedPoolWeights(_currentBPTPrices);\n\n        //Calculate the hypothetical weights if the new BPT tokens were added\n        uint256[] memory _BPTNewAmounts = new uint256[](_BPTokens.length);\n        uint256[] memory _BPTCurrentAmounts = new uint256[](_BPTokens.length);\n\n        for (uint256 i = 0; i < _BPTokens.length; i++) {\n            BPool _bPool = BPool(_BPTokens[i]);\n            _BPTCurrentAmounts[i] = _bPool.balanceOf(address(this));\n            _BPTNewAmounts[i] = _BPTCurrentAmounts[i].add(_amountsIn[i]).sub(_amountsOut[i]);\n        }\n\n        (_currentWeights, _totalPortfolioValue) = calculatePortfolioWeights(\n            _BPTCurrentAmounts,\n            _currentBPTPrices\n        );\n        if (_totalPortfolioValue == 0) {\n            _currentWeights = _idealWeights;\n        }\n\n        _nav = nav(_totalPortfolioValue);\n\n        (_hypotheticalWeights, ) = calculatePortfolioWeights(_BPTNewAmounts, _currentBPTPrices);\n\n        return (_idealWeights, _currentWeights, _hypotheticalWeights, _nav, _totalPortfolioValue);\n    }\n\n    //_amountsIn in should have a zero index if nothing has been submitted for a particular token\n    // _BPTokensIn and _amountsIn should have same indexes as poolProperties\n    function mint(\n        address[] memory _BPTokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _minGyroMinted\n    ) public override returns (uint256 amountToMint) {\n        (uint256 errorCode, Weights memory weights, FlowLogger memory flowLogger) =\n            mintChecksPassInternal(_BPTokensIn, _amountsIn, _minGyroMinted);\n        require(errorCode == 0, errorCodeToString(errorCode));\n\n        for (uint256 i = 0; i < _BPTokensIn.length; i++) {\n            bool success =\n                IERC20(_BPTokensIn[i]).transferFrom(msg.sender, address(this), _amountsIn[i]);\n            require(success, \"failed to transfer tokens, check allowance\");\n        }\n\n        amountToMint = weights.gyroAmount;\n\n        _mint(msg.sender, amountToMint);\n\n        finalizeFlowLogger(\n            flowLogger.inflowHistory,\n            flowLogger.outflowHistory,\n            weights.gyroAmount,\n            0,\n            flowLogger.currentBlock,\n            flowLogger.lastSeenBlock\n        );\n\n        emit Mint(msg.sender, amountToMint);\n\n        return amountToMint;\n    }\n\n    function mintChecksPass(\n        address[] memory _BPTokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _minGyroMinted\n    ) public view override returns (uint256 errorCode, uint256 estimatedMint) {\n        (uint256 _errorCode, Weights memory weights, ) =\n            mintChecksPassInternal(_BPTokensIn, _amountsIn, _minGyroMinted);\n\n        return (_errorCode, weights.gyroAmount);\n    }\n\n    function getReserveValues()\n        public\n        view\n        override\n        returns (\n            uint256,\n            address[] memory,\n            uint256[] memory\n        )\n    {\n        address[] memory _BPTokens = new address[](poolProperties.length);\n        uint256[] memory _zeroAmounts = new uint256[](poolProperties.length);\n        for (uint256 i = 0; i < poolProperties.length; i++) {\n            _BPTokens[i] = poolProperties[i].poolAddress;\n        }\n\n        (uint256 _errorCode, Weights memory weights, ) =\n            mintChecksPassInternal(_BPTokens, _zeroAmounts, uint256(0));\n\n        uint256[] memory _BPReserveDollarValues = new uint256[](_BPTokens.length);\n\n        for (uint256 i = 0; i < _BPTokens.length; i++) {\n            _BPReserveDollarValues[i] = weights._currentWeights[i].scaledMul(\n                weights._totalPortfolioValue\n            );\n        }\n\n        return (_errorCode, _BPTokens, _BPReserveDollarValues);\n    }\n\n    function mintChecksPassInternal(\n        address[] memory _BPTokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _minGyroMinted\n    )\n        internal\n        view\n        returns (\n            uint256 errorCode,\n            Weights memory weights,\n            FlowLogger memory flowLogger\n        )\n    {\n        require(\n            _BPTokensIn.length == _amountsIn.length,\n            \"tokensIn and valuesIn should have the same number of elements\"\n        );\n\n        //Filter 1: Require that the tokens are supported and in correct order\n        bool _orderCorrect = checkBPTokenOrder(_BPTokensIn);\n        require(_orderCorrect, \"Input tokens in wrong order or contains invalid tokens\");\n\n        uint256[] memory _allUnderlyingPrices = getAllTokenPrices();\n\n        uint256[] memory _currentBPTPrices = calculateAllPoolPrices(_allUnderlyingPrices);\n\n        weights._zeroArray = new uint256[](_BPTokensIn.length);\n        for (uint256 i = 0; i < _BPTokensIn.length; i++) {\n            weights._zeroArray[i] = 0;\n        }\n\n        (\n            weights._idealWeights,\n            weights._currentWeights,\n            weights._hypotheticalWeights,\n            weights._nav,\n            weights._totalPortfolioValue\n        ) = calculateAllWeights(_currentBPTPrices, _BPTokensIn, _amountsIn, weights._zeroArray);\n\n        bool _safeToMint =\n            safeToMint(\n                _BPTokensIn,\n                weights._hypotheticalWeights,\n                weights._idealWeights,\n                _allUnderlyingPrices,\n                _amountsIn,\n                _currentBPTPrices,\n                weights._currentWeights\n            );\n\n        if (!_safeToMint) {\n            errorCode |= WOULD_UNBALANCE_GYROSCOPE;\n        }\n\n        weights._dollarValue = 0;\n\n        for (uint256 i = 0; i < _BPTokensIn.length; i++) {\n            weights._dollarValue = weights._dollarValue.add(\n                _amountsIn[i].scaledMul(_currentBPTPrices[i])\n            );\n        }\n\n        flowLogger = initializeFlowLogger();\n\n        weights.gyroAmount = gyroPriceOracle.getAmountToMint(\n            weights._dollarValue,\n            flowLogger.inflowHistory,\n            weights._nav\n        );\n\n        if (weights.gyroAmount < _minGyroMinted) {\n            errorCode |= TOO_MUCH_SLIPPAGE;\n        }\n\n        return (errorCode, weights, flowLogger);\n    }\n\n    function redeemChecksPass(\n        address[] memory _BPTokensOut,\n        uint256[] memory _amountsOut,\n        uint256 _maxGyroRedeemed\n    ) public view override returns (uint256 errorCode, uint256 estimatedAmount) {\n        (uint256 _errorCode, Weights memory weights, ) =\n            redeemChecksPassInternal(_BPTokensOut, _amountsOut, _maxGyroRedeemed);\n        return (_errorCode, weights.gyroAmount);\n    }\n\n    function redeemChecksPassInternal(\n        address[] memory _BPTokensOut,\n        uint256[] memory _amountsOut,\n        uint256 _maxGyroRedeemed\n    )\n        internal\n        view\n        returns (\n            uint256 errorCode,\n            Weights memory weights,\n            FlowLogger memory flowLogger\n        )\n    {\n        require(\n            _BPTokensOut.length == _amountsOut.length,\n            \"tokensIn and valuesIn should have the same number of elements\"\n        );\n\n        //Filter 1: Require that the tokens are supported and in correct order\n        require(\n            checkBPTokenOrder(_BPTokensOut),\n            \"Input tokens in wrong order or contains invalid tokens\"\n        );\n\n        weights._zeroArray = new uint256[](_BPTokensOut.length);\n        for (uint256 i = 0; i < _BPTokensOut.length; i++) {\n            weights._zeroArray[i] = 0;\n        }\n\n        uint256[] memory _allUnderlyingPrices = getAllTokenPrices();\n\n        uint256[] memory _currentBPTPrices = calculateAllPoolPrices(_allUnderlyingPrices);\n\n        (\n            weights._idealWeights,\n            weights._currentWeights,\n            weights._hypotheticalWeights,\n            weights._nav,\n            weights._totalPortfolioValue\n        ) = calculateAllWeights(_currentBPTPrices, _BPTokensOut, weights._zeroArray, _amountsOut);\n\n        bool _safeToRedeem =\n            safeToRedeem(\n                _BPTokensOut,\n                weights._hypotheticalWeights,\n                weights._idealWeights,\n                weights._currentWeights\n            );\n\n        if (!_safeToRedeem) {\n            errorCode |= WOULD_UNBALANCE_GYROSCOPE;\n        }\n\n        weights._dollarValue = 0;\n\n        for (uint256 i = 0; i < _BPTokensOut.length; i++) {\n            weights._dollarValue = weights._dollarValue.add(\n                _amountsOut[i].scaledMul(_currentBPTPrices[i])\n            );\n        }\n\n        flowLogger = initializeFlowLogger();\n\n        weights.gyroAmount = gyroPriceOracle.getAmountToRedeem(\n            weights._dollarValue,\n            flowLogger.outflowHistory,\n            weights._nav\n        );\n\n        if (weights.gyroAmount > _maxGyroRedeemed) {\n            errorCode |= TOO_MUCH_SLIPPAGE;\n        }\n\n        return (errorCode, weights, flowLogger);\n    }\n\n    function redeem(\n        address[] memory _BPTokensOut,\n        uint256[] memory _amountsOut,\n        uint256 _maxGyroRedeemed\n    ) public override returns (uint256 _gyroRedeemed) {\n        (uint256 errorCode, Weights memory weights, FlowLogger memory flowLogger) =\n            redeemChecksPassInternal(_BPTokensOut, _amountsOut, _maxGyroRedeemed);\n        require(errorCode == 0, errorCodeToString(errorCode));\n\n        _gyroRedeemed = weights.gyroAmount;\n\n        _burn(msg.sender, _gyroRedeemed);\n\n        gyroRouter.withdraw(_BPTokensOut, _amountsOut);\n\n        for (uint256 i = 0; i < _amountsOut.length; i++) {\n            bool success =\n                IERC20(_BPTokensOut[i]).transferFrom(address(this), msg.sender, _amountsOut[i]);\n            require(success, \"failed to transfer tokens\");\n        }\n\n        emit Redeem(msg.sender, _gyroRedeemed);\n        finalizeFlowLogger(\n            flowLogger.inflowHistory,\n            flowLogger.outflowHistory,\n            0,\n            _gyroRedeemed,\n            flowLogger.currentBlock,\n            flowLogger.lastSeenBlock\n        );\n        return _gyroRedeemed;\n    }\n\n    function initializeFlowLogger() internal view returns (FlowLogger memory flowLogger) {\n        flowLogger.lastSeenBlock = lastSeenBlock;\n        flowLogger.currentBlock = block.number;\n        flowLogger.inflowHistory = inflowHistory;\n        flowLogger.outflowHistory = outflowHistory;\n\n        uint256 _memoryParam = memoryParam;\n\n        if (flowLogger.lastSeenBlock < flowLogger.currentBlock) {\n            flowLogger.inflowHistory = flowLogger.inflowHistory.scaledMul(\n                _memoryParam.scaledPow(flowLogger.currentBlock.sub(flowLogger.lastSeenBlock))\n            );\n            flowLogger.outflowHistory = flowLogger.outflowHistory.scaledMul(\n                _memoryParam.scaledPow(flowLogger.currentBlock.sub(flowLogger.lastSeenBlock))\n            );\n        }\n\n        return flowLogger;\n    }\n\n    function finalizeFlowLogger(\n        uint256 _inflowHistory,\n        uint256 _outflowHistory,\n        uint256 _gyroMinted,\n        uint256 _gyroRedeemed,\n        uint256 _currentBlock,\n        uint256 _lastSeenBlock\n    ) internal {\n        if (_gyroMinted > 0) {\n            inflowHistory = _inflowHistory.add(_gyroMinted);\n        }\n        if (_gyroRedeemed > 0) {\n            outflowHistory = _outflowHistory.add(_gyroRedeemed);\n        }\n        if (_lastSeenBlock < _currentBlock) {\n            lastSeenBlock = _currentBlock;\n        }\n    }\n\n    function poolAddresses() public view returns (address[] memory) {\n        address[] memory _addresses = new address[](poolProperties.length);\n        for (uint256 i = 0; i < poolProperties.length; i++) {\n            _addresses[i] = poolProperties[i].poolAddress;\n        }\n        return _addresses;\n    }\n\n    function getUnderlyingTokenAddresses() external view returns (address[] memory) {\n        address[] memory _addresses = new address[](underlyingTokenAddresses.length);\n        for (uint256 i = 0; i < underlyingTokenAddresses.length; i++) {\n            _addresses[i] = underlyingTokenAddresses[i];\n        }\n        return _addresses;\n    }\n\n    function errorCodeToString(uint256 errorCode) public pure returns (string memory) {\n        if ((errorCode & WOULD_UNBALANCE_GYROSCOPE) != 0) {\n            return \"ERR_WOULD_UNBALANCE_GYROSCOPE\";\n        } else if ((errorCode & TOO_MUCH_SLIPPAGE) != 0) {\n            return \"ERR_TOO_MUCH_SLIPPAGE\";\n        } else {\n            return \"ERR_UNKNOWN\";\n        }\n    }\n}\n"
    },
    "contracts/GyroRouter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"./GyroFund.sol\";\nimport \"./Ownable.sol\";\nimport \"./abdk/ABDKMath64x64.sol\";\n\ninterface GyroRouter {\n    function deposit(address[] memory _tokensIn, uint256[] memory _amountsIn)\n        external\n        returns (address[] memory, uint256[] memory);\n\n    function withdraw(address[] memory _tokensOut, uint256[] memory _amountsOut)\n        external\n        returns (address[] memory, uint256[] memory);\n}\n"
    },
    "contracts/GyroPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"hardhat/console.sol\";\nimport \"./balancer/BPool.sol\";\nimport \"./abdk/ABDKMath64x64.sol\";\nimport \"./compound/UniswapAnchoredView.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./ExtendedMath.sol\";\n\ninterface PriceOracle {\n    function getPrice(string memory tokenSymbol) external view returns (uint256);\n}\n\ninterface GyroPriceOracle {\n    function getAmountToMint(\n        uint256 _dollarValueIn,\n        uint256 _inflowHistory,\n        uint256 _nav\n    ) external view returns (uint256);\n\n    function getAmountToRedeem(\n        uint256 _dollarValueOut,\n        uint256 _outflowHistory,\n        uint256 _nav\n    ) external view returns (uint256 _gyroAmount);\n\n    function getBPTPrice(address _bPoolAddress, uint256[] memory _underlyingPrices)\n        external\n        view\n        returns (uint256 _bptPrice);\n}\n\ncontract GyroPriceOracleV1 is GyroPriceOracle {\n    using ExtendedMath for int128;\n    using ExtendedMath for uint256;\n    using ABDKMath64x64 for uint256;\n    using ABDKMath64x64 for int128;\n    using SafeMath for uint256;\n\n    uint256 constant bpoolDecimals = 18;\n\n    function getAmountToMint(\n        uint256 _dollarValueIn,\n        uint256 _inflowHistory,\n        uint256 _nav\n    ) external pure override returns (uint256 _gyroAmount) {\n        uint256 _one = 1e18;\n        if (_nav < _one) {\n            _gyroAmount = _dollarValueIn;\n        } else {\n            // gyroAmount = dollarValueIn * (1 - eps_inflowHistory) or min of 0\n            uint256 _eps = 1e11;\n            uint256 _scaling = _eps.scaledMul(_inflowHistory);\n            if (_scaling >= _one) {\n                _gyroAmount = 0;\n            } else {\n                _gyroAmount = _dollarValueIn.scaledMul(_one.sub(_scaling));\n            }\n        }\n        _gyroAmount = _dollarValueIn;\n        return _gyroAmount;\n    }\n\n    function getAmountToRedeem(\n        uint256 _dollarValueOut,\n        uint256 _outflowHistory,\n        uint256 _nav\n    ) external pure override returns (uint256 _gyroAmount) {\n        if (_nav < 1e18) {\n            // gyroAmount = dollarValueOut * (1 + eps*outflowHistory)\n            uint256 _eps = 1e11;\n            uint256 _scaling = _eps.scaledMul(_outflowHistory).add(1e18);\n            _gyroAmount = _dollarValueOut.scaledMul(_scaling);\n        } else {\n            _gyroAmount = _dollarValueOut;\n        }\n\n        return _gyroAmount;\n    }\n\n    function getBPTPrice(address _bPoolAddress, uint256[] memory _underlyingPrices)\n        public\n        view\n        override\n        returns (uint256 _bptPrice)\n    {\n        /* calculations:\n            bptSupply = # of BPT tokens\n            bPoolWeights = array of pool weights (require _underlyingPrices comes in same order)\n            k = constant = product of reserves^weight\n            bptPrice = (k * product of (p_i / w_i)^w_i ) / bptSupply\n\n            functions from ABDKMath64x64 library\n            -- exp_2 = binary exponent\n            -- log_2 = binary logarithm\n            -- mul = calculate x*y\n\n            x^y = 2^(y log_2 x)\n            exp_2( mul(y, log_2(x)) )\n        */\n        BPool _bPool = BPool(_bPoolAddress);\n        uint256 _bptSupply = _bPool.totalSupply();\n        address[] memory _tokens = _bPool.getFinalTokens();\n\n        uint256 _k = uint256(1e18); // check that these are the right to get value 1\n        uint256 _weightedProd = uint256(1e18);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _weight = _bPool.getNormalizedWeight(_tokens[i]);\n            uint256 _price = _underlyingPrices[i];\n            uint256 _tokenBalance = _bPool.getBalance(_tokens[i]);\n            uint256 _decimals = ERC20(_tokens[i]).decimals();\n            // _k = _k * _tokenBalance ** _weight\n            // console.log(\"balance\", _tokenBalance, \"weight\", _weight, \"decimal\", _decimals);\n\n            if (_decimals < bpoolDecimals) {\n                _tokenBalance = _tokenBalance.mul(10**(bpoolDecimals - _decimals));\n                _price = _price.mul(10**(bpoolDecimals - _decimals));\n            }\n\n            // console.log(\"balance\", _tokenBalance, \"weight\", _weight);\n            // console.log(\"decimal\", _decimals, \"price\", _price);\n\n            _k = _k.mulPow(_tokenBalance, _weight, bpoolDecimals);\n\n            // _weightedProd = _weightedProd * (_price / _weight) ** _weight;\n            _weightedProd = _weightedProd.mulPow(\n                _price.scaledDiv(_weight, bpoolDecimals),\n                _weight,\n                bpoolDecimals\n            );\n            // console.log(\"_k\", _k, \"_weightedProd\", _weightedProd);\n        }\n\n        uint256 result = _k.scaledMul(_weightedProd).scaledDiv(_bptSupply);\n        // console.log(\"final _weightedProd\", _weightedProd, \"supply\", _bptSupply);\n        console.log(\"final _k\", _k, \"result\", result);\n        return result;\n    }\n}\n\ncontract CompoundPriceWrapper is PriceOracle {\n    using SafeMath for uint256;\n\n    uint256 public constant oraclePriceScale = 1000000;\n    address public compoundOracle;\n\n    constructor(address _compoundOracle) {\n        compoundOracle = _compoundOracle;\n    }\n\n    function getPrice(string memory tokenSymbol) public view override returns (uint256) {\n        bytes32 symbolHash = keccak256(bytes(tokenSymbol));\n        if (symbolHash == keccak256(bytes(\"WETH\"))) {\n            tokenSymbol = \"ETH\";\n        }\n\n        if (symbolHash == keccak256(bytes(\"sUSD\")) || symbolHash == keccak256(bytes(\"BUSD\"))) {\n            tokenSymbol = \"DAI\";\n        }\n        UniswapAnchoredView oracle = UniswapAnchoredView(compoundOracle);\n        uint256 unscaledPrice = oracle.price(tokenSymbol);\n        TokenConfig memory tokenConfig = oracle.getTokenConfigBySymbol(tokenSymbol);\n        return unscaledPrice.mul(tokenConfig.baseUnit).div(oraclePriceScale);\n    }\n}\n\ncontract DummyPriceWrapper is PriceOracle {\n    function getPrice(string memory tokenSymbol) public pure override returns (uint256) {\n        if (keccak256(bytes(tokenSymbol)) == keccak256(bytes(\"DAI\"))) {\n            return 1e18;\n        } else if (keccak256(bytes(tokenSymbol)) == keccak256(bytes(\"USDC\"))) {\n            return 1e6;\n        } else if (keccak256(bytes(tokenSymbol)) == keccak256(bytes(\"WETH\"))) {\n            return 1350e18;\n        } else {\n            revert(\"symbol not supported\");\n        }\n    }\n}\n\n// contract MakerPriceWrapper is PriceOracle {\n//     address makerOracle;\n\n//     constructor(address _makerOracle) {\n//         makerOracle = _makerOracle;\n//     }\n\n//     // function getPrice(address token, string tokenSymbol) external returns (uint256) {\n//     //     return UniswapPriceOracle(makerOracle).getPriceOtherName(token);\n//     // }\n// }\n"
    },
    "contracts/balancer/BFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is disstributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\n// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\n\nimport \"./BPool.sol\";\n\ncontract BFactory is BBronze {\n    event LOG_NEW_POOL(address indexed caller, address indexed pool);\n\n    event LOG_BLABS(address indexed caller, address indexed blabs);\n\n    mapping(address => bool) private _isBPool;\n\n    function isBPool(address b) external view returns (bool) {\n        return _isBPool[b];\n    }\n\n    function newBPool() external returns (BPool) {\n        BPool bpool = new BPool();\n        _isBPool[address(bpool)] = true;\n        emit LOG_NEW_POOL(msg.sender, address(bpool));\n        bpool.setController(msg.sender);\n        return bpool;\n    }\n\n    address private _blabs;\n\n    constructor() {\n        _blabs = msg.sender;\n    }\n\n    function getBLabs() external view returns (address) {\n        return _blabs;\n    }\n\n    function setBLabs(address b) external {\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\n        emit LOG_BLABS(msg.sender, b);\n        _blabs = b;\n    }\n\n    function collect(BPool pool) external {\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\n        uint256 collected = BIERC20(pool).balanceOf(address(this));\n        bool xfer = pool.transfer(_blabs, collected);\n        require(xfer, \"ERR_ERC20_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}